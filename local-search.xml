<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>天才ACM</title>
    <link href="/2022/07/15/%E5%A4%A9%E6%89%8DACM/"/>
    <url>/2022/07/15/%E5%A4%A9%E6%89%8DACM/</url>
    
    <content type="html"><![CDATA[<h1 id="天才ACM"><a href="#天才ACM" class="headerlink" title="天才ACM"></a>天才ACM</h1><p>给定一个整数 $M$，对于任意一个整数集合 $S$，定义“校验值”如下:</p><p>从集合 $S$ 中取出 $M$ 对数(即 $2×M$ 个数，不能重复使用集合中的数，如果 $S$ 中的整数不够 $M$ 对，则取到不能取为止)，使得“每对数的差的平方”之和最大，这个最大值就称为集合 $S$ 的“校验值”。</p><p>现在给定一个长度为 $N$ 的数列 $A$ 以及一个整数 $T$。</p><p>我们要把 $A$ 分成若干段，使得每一段的“校验值”都不超过 $T$。</p><p>求最少需要分成几段。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数 $K$，代表有 $K$ 组测试数据。</p><p>对于每组测试数据，第一行包含三个整数 $N,M,T$ 。</p><p>第二行包含 $N$ 个整数，表示数列$A_1,A_2…A_N$。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每组测试数据，输出其答案，每个答案占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤K≤12$,<br>$1≤N,M≤500000$,<br>$0≤T≤10^{18}$,<br>$0≤A_i≤2^{20}$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">1</span> <span class="hljs-number">49</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">1</span> <span class="hljs-number">64</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>1<br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>一眼题，类似 <a href="https://lovehshan.top/2022/01/11/%E6%9C%80%E4%BD%B3%E7%89%9B%E5%9B%B4%E6%A0%8F/">最佳牛围栏</a> ，只是二分判定的方式不同，我们需要确定左区间 $l$，再二分找右区间 $r$，为了使区间 $[l,r]$ 满足题意中的 <strong>每对数的差的平方最大</strong>，只需要尽可能的让最小的减去最大的，那么我们将 $[l, r]$ 中的数排序后依次处理就好。如果满足，就将 $r$ 再扩大，不满足就缩小 $r$ ，直到 $r$ 无法继续扩大为止，此时答案数+1，再将左区间变为 $r + 1$ 继续二分就好。</p><p>代码很好写，但是这道题不止考了思路，也考了你关于时间复杂度的计算，先将代码写出，我们对照代码来计算下时间复杂度。</p><p><strong>二分法代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">500005</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> arr_a[N], arr_b[N];<br><br><span class="hljs-keyword">int</span> m；<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> t;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cheak</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123; <span class="hljs-comment">//判定函数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l; i &lt;= r; i++) &#123;<br>arr_b[i] = arr_a[i];<br>&#125;<br><br>std::<span class="hljs-built_in">sort</span>(arr_b + l, arr_b + <span class="hljs-number">1</span> + r);<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> tnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br><span class="hljs-keyword">if</span>(l + i &gt;= r - i) <span class="hljs-keyword">break</span>;<br>tnt += (arr_b[l + i] - arr_b[r - i]) * (arr_b[l + i] - arr_b[r - i]);<br>&#125;<br><br><span class="hljs-keyword">if</span>(tnt &gt; t) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Bisection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123; <span class="hljs-comment">//二分</span><br><span class="hljs-keyword">int</span> cl = l;<br><span class="hljs-keyword">while</span>(l &lt; r) &#123;<br><span class="hljs-keyword">int</span> mid = (l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">cheak</span>(cl, mid)) l = mid;<br><span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> K;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;K);<br><span class="hljs-keyword">while</span>(K--) &#123;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %lld&quot;</span>, &amp;n, &amp;m, &amp;t);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;arr_a[i]);<br>arr_b[i] = arr_a[i];<br>&#125;<br><br><span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = n, ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(l &lt;= r) &#123;<br>l = <span class="hljs-built_in">Bisection</span>(l, r) + <span class="hljs-number">1</span>;<br>ans++;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>&#125; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>二分的最坏情况是 $O(logn)$ 每一个数都是一个合法区间，而且要调用 $n$ 次，即复杂度为 $O(nlogn)$</p><p>判定函数的最坏时间复杂度为 $O(n + nlogn + m)$ 因为 $n,m$ 的数值范围一样 即得 $O(2n + nlogn)$</p><p>可得二分的最坏情况为 $O(2n^2logn + n^2log^2n)$。实际复杂度可能会少很多常数，因为我们如果每次二分都是最坏情况，那么反而判定函数的时间复杂度到不了最坏情况。</p><p>但即使少很多常数，10s内 $[1,500000]$ 也不是 $n^2$ 的算法能够解决的，于是很显然 这道题用二分会超时</p><p>继续思考，如何优化这个解法。首先是二分的最坏情况，因为二分的最坏情况满足条件是每一次折半，即为 $n,\frac{n}{2},\frac{n}{4},\frac{n}{8},………,\frac{n}{2^x}$，最后一个数一定等于一，所以有 $\frac{n}{2^x} = 1$ 变形为 $x = log_2n$。</p><p>引入一个新算法 <strong>倍增</strong></p><p>倍增算法可以用一句话简单的概括，<strong>确定左区间，每次以成倍的成长值加长，如果此次加长违法，那么成长值就会在原来的基础上减半，直到成长值为 $0$，此次倍增结束</strong></p><p>我们可以使用倍增，因为对于倍增而言，二分的最坏情况就是倍增的最优情况，但倍增的最坏情况仍然有 $O(logn)$，不要慌，对于这道题而言，倍增如果到了最坏情况，那么调用次数反而会变成 $1$ 次，而倍增如果到了最优情况，调用次数才会变成 $n$ 次。</p><p>如果是最坏情况 用倍增的复杂度就变成了 $O(logn)$，判定的复杂度没变，总复杂度就变成了 $O(2nlogn + nlog^2n)$，这道题就可以通过了</p><p>如果是最优情况 判定的复杂度会变成 $O(k)$，k为一个小常数，那么就只剩了调用次数的复杂度 $O(n)$，反而更快。</p><p>代码如下</p><p><strong>倍增法代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">500005</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> arr_a[N], arr_b[N];<br><br><span class="hljs-keyword">int</span> m;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> t;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cheak</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123; <span class="hljs-comment">//和二分法的判定函数相同</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l; i &lt;= r; i++) &#123;<br>arr_b[i] = arr_a[i];<br>&#125;<br><br>std::<span class="hljs-built_in">sort</span>(arr_b + l, arr_b + <span class="hljs-number">1</span> + r);<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> tnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br><span class="hljs-keyword">if</span>(l + i &gt;= r - i) <span class="hljs-keyword">break</span>;<br>tnt += (arr_b[l + i] - arr_b[r - i]) * (arr_b[l + i] - arr_b[r - i]);<br>&#125;<br><br><span class="hljs-keyword">if</span>(tnt &gt; t) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//变的只有这里</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BinaryL</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123; <span class="hljs-comment">//倍增过程 成长值 p，左区间 l，右区间 k，数组边界 r</span><br><span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>, k = l;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> k;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span>(k + p &lt;= r &amp;&amp; <span class="hljs-built_in">cheak</span>(l, k + p)) k += p, p *= <span class="hljs-number">2</span>; <span class="hljs-comment">//合法就加倍</span><br><span class="hljs-keyword">else</span> p /= <span class="hljs-number">2</span>; <span class="hljs-comment">//不合法就减半</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> K;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;K);<br><span class="hljs-keyword">while</span>(K--) &#123;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %lld&quot;</span>, &amp;n, &amp;m, &amp;t);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;arr_a[i]);<br>arr_b[i] = arr_a[i];<br>&#125;<br><br><span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = n, ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(l &lt;= r) &#123;<br>l = <span class="hljs-built_in">BinaryL</span>(l, r) + <span class="hljs-number">1</span>;<br>ans++;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>&#125; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>题解结束，剩下是补充内容</p><p>虽然可以AC，但是这道题还是可以继续优化，因为我们倍增的过程中，$[l,k]$ 与 $[k + 1, k + p]$ 的序列里，只有后者没有排序，前者已经排序过了，我们只需要将后者排序，再用归并排序将两个序列合并即可，归并排序将两个有序序列合并的复杂度为 $O(n)$，这样又会省下一个 $log$</p><p>最坏情况的总复杂度变为了$O(2n + nlogn)$</p><p>代码如下</p><p><strong>倍增法+归并排序代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">500005</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> arr_a[N], arr_b[N], f[N];<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> t;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt;= r; k++) &#123;<br><span class="hljs-keyword">if</span>(j &gt; r || i &lt;= mid &amp;&amp; arr_b[i] &lt;= arr_b[j]) f[k] = arr_b[i++];<br><span class="hljs-keyword">else</span> f[k] = arr_b[j++];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cheak</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = mid + <span class="hljs-number">1</span>; i &lt;= r; i++) arr_b[i] = arr_a[i];<br>std::<span class="hljs-built_in">sort</span>(arr_b + <span class="hljs-number">1</span> + mid, arr_b + <span class="hljs-number">1</span> + r);<br><span class="hljs-built_in">mergesort</span>(l, mid, r);<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> tnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br><span class="hljs-keyword">if</span>(l + i &gt;= r - i) <span class="hljs-keyword">break</span>;<br>tnt += (f[l + i] - f[r - i]) * (f[l + i] - f[r - i]);<br>&#125;<br><br><span class="hljs-keyword">if</span>(tnt &gt; t) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BinaryL</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>, k = l;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> k;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span>(k + p &lt;= r &amp;&amp; <span class="hljs-built_in">cheak</span>(l, k, k + p)) &#123;<br>k += p, p *= <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l; i &lt;= k; i++) arr_b[i] = f[i]; <span class="hljs-comment">//判定合法了再导入</span><br>&#125; <span class="hljs-keyword">else</span> p /= <span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> K;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;K);<br><span class="hljs-keyword">while</span>(K--) &#123;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %lld&quot;</span>, &amp;n, &amp;m, &amp;t);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;arr_a[i]);<br>arr_b[i] = arr_a[i];<br>&#125;<br><br><span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = n, ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(l &lt;= r) &#123;<br>l = <span class="hljs-built_in">BinaryL</span>(l, r) + <span class="hljs-number">1</span>;<br>ans++;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>&#125; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>快了6倍，而且对归并排序的理解变化运用更加自如，看到这里就推荐你去试试</p><p>以上的时间复杂度我都没乘 $K$，如果是时间复杂度计算练习，我建议还是算上。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>归并排序</tag>
      
      <tag>二分</tag>
      
      <tag>倍增</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>奇数码问题</title>
    <link href="/2022/07/04/%E5%A5%87%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <url>/2022/07/04/%E5%A5%87%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="奇数码问题"><a href="#奇数码问题" class="headerlink" title="奇数码问题"></a>奇数码问题</h1><p>你一定玩过八数码游戏，它实际上是在一个 $3×3$ 的网格中进行的，$1$ 个空格和 $1∼8$ 这 $8$ 个数字恰好不重不漏地分布在这 $3×3$ 的网格中。</p><p>例如：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">2</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> _<br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>在游戏过程中，可以把空格与其上、下、左、右四个方向之一的数字交换（如果存在）。</p><p>例如在上例中，空格可与左、上、下面的数字交换，分别变成：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">2</span> <span class="hljs-number">8</span>       <span class="hljs-number">5</span> <span class="hljs-number">2</span> _      <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">1 </span>_ <span class="hljs-number">3</span>       <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">8</span>      <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">7</span>       <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span>      <span class="hljs-number">4</span> <span class="hljs-number">6</span> _<br></code></pre></td></tr></table></figure><p>奇数码游戏是它的一个扩展，在一个 $n×n$ 的网格中进行，其中 $n$ 为奇数，$1$ 个空格和 $1∼n^2−1$ 这 $n^2−1$ 个数恰好不重不漏地分布在 $n×n$ 的网格中。</p><p>空格移动的规则与八数码游戏相同，实际上，八数码就是一个 $n=3$ 的奇数码游戏。</p><p>现在给定两个奇数码游戏的局面，请判断是否存在一种移动空格的方式，使得其中一个局面可以变化到另一个局面。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>多组数据，对于每组数据：</p><p>第 $1$ 行输入一个整数 $n$，$n$ 为奇数。</p><p>接下来 $n$ 行每行 $n$ 个整数，表示第一个局面。</p><p>再接下来 $n$ 行每行 $n$ 个整数，表示第二个局面。</p><p>局面中每个整数都是 $0∼n^2−1$ 之一，其中用 $0$ 代表空格，其余数值与奇数码游戏中的意义相同，保证这些整数的分布不重不漏。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每组数据，若两个局面可达，输出 <code>TAK</code>，否则输出 <code>NIE</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n&lt;500$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">4</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">5</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">8</span> <span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">TAK</span><br><span class="hljs-attribute">TAK</span><br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>首先一眼题，很简单的办法便是爆搜，终止条件我们只需要看空格位置是否重合，如果重合我们便与答案局面对照，如果相同则可以到达，不同则继续搜索，最后如果没有符合条件的答案便表示不能到达。</p><p>部分代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(x + <span class="hljs-number">1</span> &lt;= n * n &amp;&amp; flag != <span class="hljs-number">1</span>) &#123;<br>std::<span class="hljs-built_in">swap</span>(a[x], a[x + <span class="hljs-number">1</span>]);<br><span class="hljs-built_in">dfs</span>(a, x + <span class="hljs-number">1</span>);<br>std::<span class="hljs-built_in">swap</span>(a[x], a[x - <span class="hljs-number">1</span>]);<br>&#125; <span class="hljs-keyword">if</span>(x - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">1</span> &amp;&amp; flag != <span class="hljs-number">1</span>) &#123;<br>std::<span class="hljs-built_in">swap</span>(a[x], a[x - <span class="hljs-number">1</span>]);<br><span class="hljs-built_in">dfs</span>(a, x - <span class="hljs-number">1</span>);<br>std::<span class="hljs-built_in">swap</span>(a[x], a[x + <span class="hljs-number">1</span>]);<br>&#125; <span class="hljs-keyword">if</span>(x + (n - <span class="hljs-number">1</span>) &lt;= n * n &amp;&amp; flag != <span class="hljs-number">1</span>) &#123;<br>std::<span class="hljs-built_in">swap</span>(a[x], a[x + (n - <span class="hljs-number">1</span>)]);<br><span class="hljs-built_in">dfs</span>(a, x + (n - <span class="hljs-number">1</span>));<br>std::<span class="hljs-built_in">swap</span>(a[x], a[x - (n - <span class="hljs-number">1</span>)]);<br>&#125; <span class="hljs-keyword">if</span>(x - (n - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">1</span> &amp;&amp; flag != <span class="hljs-number">1</span>) &#123;<br>std::<span class="hljs-built_in">swap</span>(a[x], a[x - (n - <span class="hljs-number">1</span>)]);<br><span class="hljs-built_in">dfs</span>(a, x - (n - <span class="hljs-number">1</span>));<br>std::<span class="hljs-built_in">swap</span>(a[x], a[x + (n - <span class="hljs-number">1</span>)]);<br>&#125; <br></code></pre></td></tr></table></figure><p>很明显这道题并不能用这个，我的爆搜时间复杂度为 $O(n^3)$ ，且这道题还是多道数据</p><p>在二维上解决不了，考虑将二维转一维，由题中样例可得转化后的一维图为</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">2</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> _<br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">7</span><br><br><span class="hljs-symbol">5 </span><span class="hljs-number">2</span> <span class="hljs-number">8</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> _ <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>此样例无法向右交换，但我们可以得到它的其他三种交换后状态 分别为</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">原<span class="hljs-number"> 5 </span>2<span class="hljs-number"> 8 </span>1<span class="hljs-number"> 3 </span>_<span class="hljs-number"> 4 </span>6 7<br>左<span class="hljs-number"> 5 </span>2<span class="hljs-number"> 8 </span>1 _<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 6 </span>7<br>上<span class="hljs-number"> 5 </span>2 _<span class="hljs-number"> 1 </span>3<span class="hljs-number"> 8 </span>4<span class="hljs-number"> 6 </span>7<br>下<span class="hljs-number"> 5 </span>2<span class="hljs-number"> 8 </span>1<span class="hljs-number"> 3 </span>7<span class="hljs-number"> 4 </span>6 _<br></code></pre></td></tr></table></figure><p>根据向 左 的移动状态可以知道，在空格移动后原数据的相对位置不变，同理 向右也如此。</p><p>根据向 上下 的移动状态可以知道，在空格移动后部分原数据的相对位置发生改变，改变的数量为 $n$ 个</p><p>从目前是看不出任何东西的，继续思考。此问题为一种 <strong>有解性判定</strong> 若只考虑输入数列而不考虑结果数列可能并不能得到答案</p><p>于是考虑样例</p><p>输入局面</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> _ <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>结果局面</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> _<br></code></pre></td></tr></table></figure><p>易得，想要从输入局面到结果局面 将空格先向右交换然后向下交换，最后再向右交换</p><p>分别为</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> _ <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> _ <span class="hljs-number">8</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> _<br></code></pre></td></tr></table></figure><p>空格对数的交换对数列造成了哪些影响？左右交换是改变了一个数的位置，但对一整段数列而言这一个数的相对位置并没有改变，而上下交换却影响的 $n$ 个数的相对位置，有什么办法能快速记录这 $n$ 个数的影响吗？我们发现，根据题意整段数列不存在相同的数，于是我们可以通过记录 <strong>逆序对</strong> 的方法，来记录这 $n$ 个数的影响。</p><p>比如</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> _ <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> 改变的逆序对个数为 <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> _ <span class="hljs-number">8</span> 改变的逆序对个数为 -<span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> _ 改变的逆序对个数为 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以发现，左右移动不会使逆序对的个数改变，而上下移动会对逆序对的个数改变，因为数列的长度始终为奇数，<strong>所以空格每次交换，在数列上的表现一定是移动奇数个单位</strong>，从而使 $n - 1$ 个数与空格交换的数的相对位置发生改变。</p><p>因此，我们就可以将这 $n$ 个数的各种情况举例出来，看是否存在某种规律。跟上面同理，我们将一段 $n = 3$ 的数列的空格向上移动，就有</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs llvm">a b <span class="hljs-keyword">c</span> d e _ g h i<br><span class="hljs-keyword">c</span> d e _<br>_ d e <span class="hljs-keyword">c</span><br><br>前面是数列各数的关系，后面是逆序对改变前和改变后的数量<br><span class="hljs-keyword">c</span> &gt; d &gt; e <span class="hljs-number">0</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">c</span> &gt; e &gt; d <span class="hljs-number">2</span> <span class="hljs-number">0</span><br>d &gt; <span class="hljs-keyword">c</span> &gt; e <span class="hljs-number">2</span> <span class="hljs-number">2</span><br>d &gt; e &gt; <span class="hljs-keyword">c</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br>e &gt; d &gt; <span class="hljs-keyword">c</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <br>e &gt; <span class="hljs-keyword">c</span> &gt; d <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p> 我们发现，除了两个逆序对相等的情况，其他都改变了 2 个。</p><p>同样我们也可以推出 $n = 5$ 的情况</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">q w e r t<br>y u i o p<br><span class="hljs-keyword">a</span> s _ f g<br>h j k l z<br>x c v b n<br><br>q w e r t y u i o p <span class="hljs-keyword">a</span> s _ f g h j k l z x c v b n 原<br>q w e r t y u i o p <span class="hljs-keyword">a</span> _ s f g h j k l z x c v b n 左<br>q w e r t y u i o p <span class="hljs-keyword">a</span> s f _ g h j k l z x c v b n 右<br>q w e r t y u _ o p <span class="hljs-keyword">a</span> s i f g h j k l z x c v b n 上<br><br>向上移动，部分变成了<br>o p <span class="hljs-keyword">a</span> s i<br>i o p <span class="hljs-keyword">a</span> s<br><br>前面是数列各数的关系，后面是逆序对改变前和改变后的数量<br>i &gt; o &gt; p &gt; <span class="hljs-keyword">a</span> &gt; s <span class="hljs-number">6</span> <span class="hljs-number">10</span><br>i &gt; o &gt; p &gt; s &gt; <span class="hljs-keyword">a</span> <span class="hljs-number">5</span> <span class="hljs-number">9</span><br>i &gt; o &gt; <span class="hljs-keyword">a</span> &gt; p &gt; s <span class="hljs-number">5</span> <span class="hljs-number">9</span><br>i &gt; o &gt; <span class="hljs-keyword">a</span> &gt; s &gt; p <span class="hljs-number">4</span> <span class="hljs-number">8</span><br>i &gt; o &gt; s &gt; <span class="hljs-keyword">a</span> &gt; p <span class="hljs-number">3</span> <span class="hljs-number">7</span><br>i &gt; o &gt; s &gt; p &gt; <span class="hljs-keyword">a</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span><br>（因为太多 只列举部分，但这个部分可能会产生误导）<br>（从这里可能会误导，|结果数列的逆序对数量-输入数列的逆序对数量| = n - <span class="hljs-number">1</span>，所以我特地找了个数据）<br><span class="hljs-keyword">a</span> &gt; p &gt; o &gt; i &gt; s <span class="hljs-number">6</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>可以发现，每次向上（下）移动后逆序对的个数改变都为偶数个，因为我们将空格移动后，将会改变奇数个数的相对位置，但若看成将某个数移动到空格的位置上，就相当于这个数与前面 $n - 1$ 个数交换了位置，因为 $n - 1$ 为偶数，所以逆序对的变化也一定为偶数，为什么？看 $n = 3$ 时举的例子，同样，当 $n &gt; 3 且 n\mod 2≠0$ 时，都可以简化为 $n = 3$ 的情况</p><p>因此我们可以得到，向左右移动时，数列的逆序对数量不变，向上下移动时，数列的逆序对奇偶性不变，<strong>若结果数列的逆序对个数的奇偶性与输入数列的逆序对个数的奇偶性相同，则说明可以到达，反之则不能</strong>，这句话也可以换个意思，由我们模拟的样例可以得到，假如想要从结果数列到达输入数列，**那么必定可以得到 |结果数列的逆序对个数 - 输入数列的逆序对个数| Mod 2 = 0 **，于是我们只需要得到这两个数列的逆序对个数就可以得到我们最终的答案。</p><p>最后要注意逆序对的个数要开long long，最坏情况为递减数列，即最大逆序对的个数为 $2n^2$ 即为 $250000^2$ 会爆int（但此题的数据并没有卡这个） </p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">500</span> * <span class="hljs-number">500</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> arr[MAXN], brr[MAXN], b[MAXN];<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[MAXN], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt;= r; k++) &#123;<br><span class="hljs-keyword">if</span>(j &gt; r || i &lt;= mid &amp;&amp; a[i] &lt;= a[j]) b[k] = a[i++];<br><span class="hljs-keyword">else</span> b[k] = a[j++], cnt += mid - i + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt;= r; k++) a[k] = b[k];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> a[MAXN])</span> </span>&#123;<br><span class="hljs-keyword">if</span>(l &lt; r) &#123;<br><span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">merge</span>(l, mid, a);<br><span class="hljs-built_in">merge</span>(mid + <span class="hljs-number">1</span>, r, a);<br><span class="hljs-built_in">mergeSort</span>(a, l, mid, r);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123; <span class="hljs-comment">//多组数据的输入方式</span><br><span class="hljs-keyword">int</span> kx = <span class="hljs-number">0</span>, ky = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n * n; i++) &#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br><span class="hljs-keyword">if</span>(x != <span class="hljs-number">0</span>) arr[++kx] = x;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n * n; i++) &#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br><span class="hljs-keyword">if</span>(x != <span class="hljs-number">0</span>) brr[++ky] = x;<br>&#125;<br><br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;TAK&quot;</span>); <span class="hljs-keyword">continue</span>; &#125;<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans_arr = <span class="hljs-number">0</span>, ans_brr = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">merge</span>(<span class="hljs-number">1</span>, kx, arr);<br>ans_arr = cnt, cnt = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">merge</span>(<span class="hljs-number">1</span>, ky, brr);<br>ans_brr = cnt, cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span>((ans_arr &amp; <span class="hljs-number">1</span>) != (ans_brr &amp; <span class="hljs-number">1</span>)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NIE&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(std::<span class="hljs-built_in">abs</span>(ans_brr - ans_arr) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;TAK&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NIE&quot;</span>);<br>&#125; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>逆序对</tag>
      
      <tag>归并排序</tag>
      
      <tag>有解性判定</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超快速排序</title>
    <link href="/2022/07/02/%E8%B6%85%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/07/02/%E8%B6%85%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="超快速排序"><a href="#超快速排序" class="headerlink" title="超快速排序"></a>超快速排序</h1><p>在这个问题中，您必须分析特定的排序算法—-超快速排序。</p><p>该算法通过交换两个相邻的序列元素来处理 $n$ 个不同整数的序列，直到序列按升序排序。</p><p>对于输入序列 <code>9 1 0 5 4</code>，超快速排序生成输出 <code>0 1 4 5 9</code>。</p><p>您的任务是确定超快速排序需要执行多少交换操作才能对给定的输入序列进行排序。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包括一些测试用例。</p><p>每个测试用例的第一行输入整数 $n$，代表该用例中输入序列的长度。</p><p>接下来 $n$ 行每行输入一个整数 $a_i$,代表用例中输入序列的具体数据，第 $i$ 行的数据代表序列中第 $i$ 个数。</p><p>当输入用例中包含的输入序列长度为 $0$ 时，输入终止，该序列无需处理。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个需要处理的输入序列，输出一个整数 $op$，代表对给定输入序列进行排序所需的最小交换操作数，每个整数占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0≤n&lt;500000$,<br>一个测试点中，所有 $n$ 的和不超过 $500000$。<br>$0≤a_i≤999999999$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs">5<br>9<br>1<br>0<br>5<br>4<br>3<br>1<br>2<br>3<br>0<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">6<br>0<br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>每次只能移动两个相邻的数，直到序列递增，简单的算法便是 $O(n^2)$ 的冒泡排序 ，但很明显这道题的数据并不能通过。通过题目样例模拟又可得到，一个数的移动和它所形成的逆序对有关，比如</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">9 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>9 移动到最后一位需要 4 步，而它所形成的逆序对也为 4。</p><p>所以我们只需要计算该序列的逆序对即可，而计算逆序对的方法便是归并排序（模拟一遍归并排序的过程，即二叉树从最底层的叶子结点推到根节点），时间复杂度为$O(nlogn)$ ，这个复杂度可过</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">500005</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[MAXN], f[MAXN];<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cnt;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt;= r; k++) &#123;<br>        <span class="hljs-keyword">if</span>(j &gt; r || i &lt;= mid &amp;&amp; a[i] &lt;= a[j]) f[k] = a[i++];<br>        <span class="hljs-keyword">else</span> f[k] = a[j++], cnt += mid - i + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt;= r; k++) a[k] = f[k];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l &lt; r) &#123;<br>        <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">merge</span>(l, mid);<br>        <span class="hljs-built_in">merge</span>(mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-built_in">mergesort</span>(l, mid, r);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n)) &#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br>        <span class="hljs-built_in">merge</span>(<span class="hljs-number">1</span>, n);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, cnt);<br>    &#125; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>逆序对</tag>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态中位数</title>
    <link href="/2022/07/02/%E5%8A%A8%E6%80%81%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2022/07/02/%E5%8A%A8%E6%80%81%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="动态中位数"><a href="#动态中位数" class="headerlink" title="动态中位数"></a>动态中位数</h1><p>依次读入一个整数序列，每当已经读入的整数个数为奇数时，输出已读入的整数构成的序列的中位数。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入一个整数 $P$，代表后面数据集的个数，接下来若干行输入各个数据集。</p><p>每个数据集的第一行首先输入一个代表数据集的编号的整数。</p><p>然后输入一个整数 $M$，代表数据集中包含数据的个数，$M$ 一定为奇数，数据之间用空格隔开。</p><p>数据集的剩余行由数据集的数据构成，每行包含 $10$ 个数据，最后一行数据量可能少于 $10$ 个，数据之间用空格隔开。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个数据集，第一行输出两个整数，分别代表数据集的编号以及输出中位数的个数（应为数据个数加一的二分之一），数据之间用空格隔开。</p><p>数据集的剩余行由输出的中位数构成，每行包含 $10$ 个数据，最后一行数据量可能少于 $10$ 个，数据之间用空格隔开。</p><p>输出中不应该存在空行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤P≤1000$,<br>$1≤M≤99999$,<br>所有 $M$ 相加之和不超过 $5×10^5$。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">3 <br>1<span class="hljs-number"> 9 </span><br>1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 8 </span>9 <br>2<span class="hljs-number"> 9 </span><br>9<span class="hljs-number"> 8 </span>7<span class="hljs-number"> 6 </span>5<span class="hljs-number"> 4 </span>3<span class="hljs-number"> 2 </span>1 <br>3<span class="hljs-number"> 23 </span><br>23<span class="hljs-number"> 41 </span>13<span class="hljs-number"> 22 </span>-3<span class="hljs-number"> 24 </span>-31 -11 -8 -7 <br>3<span class="hljs-number"> 5 </span>103<span class="hljs-number"> 211 </span>-311 -45 -67 -73 -81 -99 <br>-33<span class="hljs-number"> 24 </span>56<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">1 5<br>1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<br>2 5<br>9<span class="hljs-number"> 8 </span>7<span class="hljs-number"> 6 </span>5<br>3 12<br>23<span class="hljs-number"> 23 </span>22<span class="hljs-number"> 22 </span>13<span class="hljs-number"> 3 </span>5<span class="hljs-number"> 5 </span>3 -3 <br>-7 -3<br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>动态维护中位数，如果不考虑动态且假设这个数组的长度为 $m$，即离线找一个数组的中位数，就是排序后找数组中下标为 $\left \lfloor \frac{m + 1}{2} \right \rfloor$ 的数。</p><p>左边都是小于等于中位数的数，右边都是大于等于中位数的数，一边读取一边动态维护，很显然，左边我们用<strong>大根堆</strong>维护，右边我们用<strong>小根堆</strong>维护，只要保证左边的总数为 $\left \lfloor \frac{m}{2}\right \rfloor$，右边的总数为 $\left \lfloor \frac{m + 1}{2} \right \rfloor$  ，那么我们的中位数永远是小根堆的顶端</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-comment">//可以不用手搓二叉树，用优先队列 std::priority_queue 也可解决</span><br><span class="hljs-comment">//std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt;  为小根堆</span><br><span class="hljs-comment">//std::priority_queue&lt;int&gt; 为大根堆</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100005</span>;<br><span class="hljs-keyword">int</span> arr[N], bigtree[N], smalltree[N];<br><br><span class="hljs-comment">//b 开头为大根堆， s 开头为小根堆</span><br><span class="hljs-keyword">int</span> btnt, stnt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br><span class="hljs-keyword">while</span>(s &gt; <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span>(bigtree[s / <span class="hljs-number">2</span>] &lt; bigtree[s]) &#123;<br>std::<span class="hljs-built_in">swap</span>(bigtree[s], bigtree[s / <span class="hljs-number">2</span>]);<br>s = s / <span class="hljs-number">2</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br><span class="hljs-keyword">int</span> t = s * <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span>(t &lt;= btnt) &#123;<br><span class="hljs-keyword">if</span>(t &lt; btnt &amp;&amp; bigtree[t] &lt; bigtree[t + <span class="hljs-number">1</span>]) t++;<br><span class="hljs-keyword">if</span>(bigtree[s] &lt; bigtree[t]) &#123;<br>std::<span class="hljs-built_in">swap</span>(bigtree[s], bigtree[t]);<br>s = t;<br>t = s * <span class="hljs-number">2</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br><span class="hljs-keyword">int</span> t = s * <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span>(t &lt;= stnt) &#123;<br><span class="hljs-keyword">if</span>(t &lt; stnt &amp;&amp; smalltree[t] &gt; smalltree[t + <span class="hljs-number">1</span>]) t++;<br><span class="hljs-keyword">if</span>(smalltree[s] &gt; smalltree[t]) &#123;<br>std::<span class="hljs-built_in">swap</span>(smalltree[s], smalltree[t]);<br>s = t;<br>t = s * <span class="hljs-number">2</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br><span class="hljs-keyword">while</span>(s &gt; <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span>(smalltree[s / <span class="hljs-number">2</span>] &gt; smalltree[s]) &#123;<br>std::<span class="hljs-built_in">swap</span>(smalltree[s], smalltree[s / <span class="hljs-number">2</span>]);<br>s = s / <span class="hljs-number">2</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bGetTop</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> bigtree[<span class="hljs-number">1</span>]; &#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sGetTop</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> smalltree[<span class="hljs-number">1</span>]; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>btnt += <span class="hljs-number">1</span>;<br>bigtree[btnt] = val;<br><span class="hljs-built_in">bup</span>(btnt);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>stnt += <span class="hljs-number">1</span>;<br>smalltree[stnt] = val;<br><span class="hljs-built_in">sup</span>(stnt);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bExtract</span><span class="hljs-params">()</span> </span>&#123;<br>bigtree[<span class="hljs-number">1</span>] = bigtree[btnt--];<br><span class="hljs-built_in">bdown</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sExtract</span><span class="hljs-params">()</span> </span>&#123;<br>smalltree[<span class="hljs-number">1</span>] = smalltree[stnt--];<br><span class="hljs-built_in">sdown</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> T, tot;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<br><span class="hljs-keyword">while</span>(T--) &#123;<br><span class="hljs-built_in">memset</span>(arr, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr)); stnt = <span class="hljs-number">0</span>, btnt = <span class="hljs-number">0</span>, tot = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> m, n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, m, (n + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br><span class="hljs-keyword">if</span>(stnt == <span class="hljs-number">0</span>) <span class="hljs-built_in">sInsert</span>(arr[i]);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span>(arr[i] &gt; <span class="hljs-built_in">sGetTop</span>()) <span class="hljs-built_in">sInsert</span>(arr[i]);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">bInsert</span>(arr[i]);<br><br>                <span class="hljs-comment">//这里注意条件，看不明白去看上面的解析</span><br><span class="hljs-keyword">if</span>(btnt &gt; stnt) &#123; <span class="hljs-built_in">sInsert</span>(<span class="hljs-built_in">bGetTop</span>()); <span class="hljs-built_in">bExtract</span>(); &#125;<br><span class="hljs-keyword">if</span>(btnt + <span class="hljs-number">1</span> &lt; stnt) &#123; <span class="hljs-built_in">bInsert</span>(<span class="hljs-built_in">sGetTop</span>()); <span class="hljs-built_in">sExtract</span>(); &#125;<br>&#125; <span class="hljs-keyword">if</span>(i &amp; <span class="hljs-number">1</span>) &#123; tot++; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-built_in">sGetTop</span>()); &#125;<br>            <span class="hljs-comment">//如果为奇数就输出，注意每行10个的条件，且注意 数据会卡tot正好为10的时候</span><br><span class="hljs-keyword">if</span>(tot == <span class="hljs-number">10</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>); tot = <span class="hljs-number">0</span>; &#125;<br>&#125; <span class="hljs-keyword">if</span>(tot != <span class="hljs-number">0</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>七夕祭</title>
    <link href="/2022/06/30/%E4%B8%83%E5%A4%95%E7%A5%AD/"/>
    <url>/2022/06/30/%E4%B8%83%E5%A4%95%E7%A5%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="七夕祭"><a href="#七夕祭" class="headerlink" title="七夕祭"></a>七夕祭</h1><p>七夕节因牛郎织女的传说而被扣上了「情人节」的帽子。</p><p>于是 TYVJ 今年举办了一次线下七夕祭。</p><p>Vani 同学今年成功邀请到了 cl 同学陪他来共度七夕，于是他们决定去 TYVJ 七夕祭游玩。</p><p>TYVJ 七夕祭和 11 区的夏祭的形式很像。</p><p>矩形的祭典会场由 $N$ 排 $M$ 列共计 $N×M$ 个摊点组成。</p><p>虽然摊点种类繁多，不过 cl 只对其中的一部分摊点感兴趣，比如章鱼烧、苹果糖、棉花糖、射的屋……什么的。</p><p>Vani 预先联系了七夕祭的负责人 zhq，希望能够通过恰当地布置会场，使得各行中 cl 感兴趣的摊点数一样多，并且各列中 cl 感兴趣的摊点数也一样多。</p><p>不过 zhq 告诉 Vani，摊点已经随意布置完毕了，如果想满足 cl 的要求，唯一的调整方式就是交换两个相邻的摊点。</p><p>两个摊点相邻，当且仅当他们处在同一行或者同一列的相邻位置上。</p><p>由于 zhq 率领的 TYVJ 开发小组成功地扭曲了空间，每一行或每一列的第一个位置和最后一个位置也算作相邻。</p><p>现在 Vani 想知道他的两个要求最多能满足多少个。</p><p>在此前提下，至少需要交换多少次摊点。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 $N$ 和 $M$ 和 $T$，$T$ 表示 cl 对多少个摊点感兴趣。</p><p>接下来 $T$ 行，每行两个整数 $x,y$，表示 cl 对处在第 $x$ 行第 $y$ 列的摊点感兴趣。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>首先输出一个字符串。</p><p>如果能满足 Vani 的全部两个要求，输出 both；</p><p>如果通过调整只能使得各行中 cl 感兴趣的摊点数一样多，输出 row；</p><p>如果只能使各列中 cl 感兴趣的摊点数一样多，输出 column；</p><p>如果均不能满足，输出 impossible。</p><p>如果输出的字符串不是 impossible， 接下来输出最小交换次数，与字符串之间用一个空格隔开。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤N,M≤100000$,<br>$0≤T≤min(N∗M,100000)$,<br>$1≤x≤N$,<br>$1≤y≤M$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">row</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>引入一个前置题 <a href="https://www.acwing.com/problem/content/1538/">均分纸牌</a></p><p>此题就是在均分纸牌上加了三个条件</p><p>1、变成一个二维题</p><p>2、将链变成环（首尾可交换）</p><p>3、每次只能转移一个点</p><p>简化模型，先解决均分纸牌，简述一下题意，有 $n$ 个牌堆，每个牌堆里有 $a_i$ 个牌，现在要将每个牌堆的牌数变为相同的，每次操作可以将任意牌堆的任意张牌移动到相邻的牌堆中，请问最少需要多少个操作将所有牌堆的牌数变为相同的。</p><p>那么我们可以很容易的得到一个解决办法：首先得到最后我们所有牌堆中应当有多少张牌，很简单T =  $\frac{\Sigma_{i = 1}^n a_i}{n}$ ，然后将每个牌堆的牌数 $a_i$ 减去这个 $T$，就可以得到每个牌堆的牌数距离满足条件的牌数还差多少张牌，<strong>每个牌堆想要获得牌只能由相邻的牌堆进行提供，所以我们只需要从第一个牌堆开始考虑，按照多出少补的原则进行递推</strong>，比如：第一个牌堆缺 5 张牌，那么一定是从第二个牌堆中得到 5 张牌，或者第一个牌堆多 5 张牌，那么一定是给第二个牌堆 5 张牌。得到 5 张牌很好处理，因为第一个牌堆缺 5 张牌，所以第一个牌堆的当前数一定是 -5，直接将 -5 加到第二个牌堆上即可，给出 5 张牌也是同理。</p><p>那么此时就会出现两种情况</p><p>1、给出牌，或者拿走牌之后 第二个牌堆的牌数不为零，那么继续以上操作 并且记录答案+1</p><p>2、给出牌，或者拿走牌之后 第二个牌堆的牌数为零，那么此时第二堆牌不需要再给或拿第三个堆牌，在进行第二堆到第三堆的操作时不需要使答案数增加</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-keyword">int</span> arr[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>    <br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) t += arr[i]; t /= n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) arr[i] -= t;<br>    <br>    <span class="hljs-keyword">int</span> tnt = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        tnt += arr[i];<br>        ans++; <span class="hljs-keyword">if</span>(tnt == <span class="hljs-number">0</span>) ans--;<br>    &#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么解决这个问题之后，我们再来解决这道 <strong>七夕祭</strong></p><p>三个问题依次解决，<strong>首先是第一个问题</strong></p><p>由样例画图易得，无论摊点的位置如何变化，总行和总列上的摊点总数不会变，那么我们只需要将行和列看成一条线单独处理就好了</p><p><strong>紧接着是第二个问题（难点）</strong></p><p>这道题将链变为了环，事情好像一下就变得非常复杂了，似乎我们不能再从第一个点递推了，产生了非常多的情况。为了解决这个问题，我们仍然使用简化模型的方式将所有情况列举出来。我们可以发现，所有情况都可以简化为三个摊点的移动情况，那么可得证明（如图）</p><p><img src="https://s1.ax1x.com/2022/06/30/jKvJeK.jpg"></p><p>未列举所有摊点的关系，但都同理，注意：不存在三个都大于零与三个都小于零的情况。</p><p>由图我们可以得到，即使图形为环，为了保证结果最优总会有两个摊点间不会进行交换，那么我们将这个环从这两点间断开当成链处理，就和 <strong>均分纸牌</strong> 一样了。</p><p><strong>最后一个问题（难点）</strong></p><p>每次只能移动一个点，假如将这个条件加入到 <strong>均分纸牌</strong> 中，借用均分纸牌的样例</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">9 </span><span class="hljs-number">8</span> <span class="hljs-number">17</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>我们最后要得到的数为 10 10 10 10，直接数的话我们可以得到操作数为 8</p><p>为了好理解，我们模拟一遍从第一个牌堆到第三个牌堆的过程，我们现在要从第一个牌堆中拿 -1 个牌到第三个牌堆，要先经过第二个牌堆，再到第三个牌堆。这 -1 个牌我们是要经过第二个牌堆的，有什么方法能让我们一次性处理完全部牌堆呢？一个方法就呼之欲出 <strong>前缀和</strong>，我们将每个牌堆的牌数先 -10，得到</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-string">-1</span> <span class="hljs-string">-2</span> 7 <span class="hljs-string">-4</span><br></code></pre></td></tr></table></figure><p>然后计算前缀和，得到</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-string">-1</span> <span class="hljs-string">-3</span> 4 0<br></code></pre></td></tr></table></figure><p>然后将这些数的绝对值加起来，就得到了我们的总操作数 8。</p><p>这个前缀和的操作就相当于模拟了给牌的过程<strong>（关键，注意理解）</strong></p><p>于是可以易得我们的答案方程 $ans = \Sigma_{i = 1}^n|G_i - i \times \frac{T}{n}|$ ，$T$ 为总牌数，$n$ 为牌堆数， $G_i$ 为第 $i$ 个牌堆的前缀和</p><p>解决完这三个问题，回到题目本身，对于题目的解决，我们仍需要得到一个数据，即断开点 $k$ 的位置。很简单的方法就是爆搜，但很明显对于这道题而言会超时，那么我们就需要从别处下手。<strong>对于一道有答案方程的题，可以考虑从答案方程入手。</strong></p><p>假设已知断开点 $k$ 的位置（即 $S_k$ 为尾而 $S_{k+1}$ 为首），原前缀和为</p><p>$G_1,G_2,G_3,…,G_k,G_{k+1},…G_{n}$</p><p>断开后变为了</p><p>$G_{k+1} - G_{k},G_{k+2} - G_k,…,G_n - G_k,G_1 + G_n - G_k,…,G_k + G_n - G_k$ </p><p>由于要想结果成立，可以得到 $G_n = T$ ，我们将原数组的每项先减去 $\frac{T}{n}$ ，那么就可以得到 $G_n = 0$</p><p>于是原式就可以看作为一个通项式 $G_i - G_k$，由于我们原数组的每项先减去了 $\frac{T}{n}$<strong>（注意对比，上面的答案方程的原数组并没有变化）</strong>，所以我们的答案方程就是 $ans = \Sigma_{i = 1}^n|G_i - G_k|$ </p><p>在一个一维线上（我们已经将二维图形转化了两条一维线，不懂可以回到我们解决的<strong>一问题</strong>），为了便于理解，我们假设 $G_i$ 数组变为了一段依次增大的代表当前坐标的x轴上的数（比如 -2 -1 0 1 2）， $\Sigma_{i=1}^n|G_i-G_k|$ 含义便是各点到 $k$ 点的距离总和，这个 $k$ 是未知的，我们的答案要求<strong>最小交换次数</strong>，在这里就是让各点到 $k$ 点的距离总和尽量的小。回忆一下，让各点到 $k$ 点的距离总和尽可能的小，这不就是 <a href="https://lovehshan.top/2022/01/16/%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80/">货仓选址</a> 嘛，我们只需要让这个 $k$ 点在中点就可以让结果最优，<strong>前提是保证这个数列一定是单调的。</strong></p><p>于是我们得到了这个 $k$ 的解决办法，直接把这个前缀和排序，将这个答案方程带入就可以AC了。</p><p>这道题融合了两道题的思路，并且提出了环状问题的解决思路，代码简单思路较难的好题，建议自己看完后隔一天再自己捋一遍这道题。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100005</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> xl[N], yl[N], f[N]; <span class="hljs-comment">//注意long long 会爆int</span><br><br><span class="hljs-comment">//懂了思路这里就是小模拟</span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">handle</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> arr[N], <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) f[i] = f[i - <span class="hljs-number">1</span>] + arr[i] - arr[<span class="hljs-number">0</span>] / n;<br><br>std::<span class="hljs-built_in">sort</span>(f + <span class="hljs-number">1</span>, f + <span class="hljs-number">1</span> + n);<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>ans += std::<span class="hljs-built_in">abs</span>(f[i] - f[(n + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>]);<br>&#125; <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> n, m, t;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;t);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= t; i++) &#123;<br><span class="hljs-keyword">int</span> x, y;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);<br>xl[x]++, yl[y]++;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) xl[<span class="hljs-number">0</span>] += xl[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) yl[<span class="hljs-number">0</span>] += yl[i];<br><br><span class="hljs-keyword">if</span>(xl[<span class="hljs-number">0</span>] % n == <span class="hljs-number">0</span> &amp;&amp; yl[<span class="hljs-number">0</span>] % m == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;both %lld&quot;</span>, <span class="hljs-built_in">handle</span>(xl, n) + <span class="hljs-built_in">handle</span>(yl, m));<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(xl[<span class="hljs-number">0</span>] % n == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;row %lld&quot;</span>, <span class="hljs-built_in">handle</span>(xl, n));<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(yl[<span class="hljs-number">0</span>] % m == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;column %lld&quot;</span>, <span class="hljs-built_in">handle</span>(yl, m));<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>前缀和</tag>
      
      <tag>中位数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>货仓选址</title>
    <link href="/2022/01/16/%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80/"/>
    <url>/2022/01/16/%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h1 id="货仓选址"><a href="#货仓选址" class="headerlink" title="货仓选址"></a>货仓选址</h1><p>在一条数轴上有 $N$ 家商店，它们的坐标分别为 $A_1…A_N$。<br>现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。</p><p>为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。</p><p><strong>输入格式</strong></p><p>第一行输入整数$N$。</p><p>第二行$N$个整数$A_1…A_N$。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示距离之和的最小值。</p><p><strong>数据范围</strong></p><p>$1≤N≤100000$</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">2</span> <span class="hljs-number">9</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">12<br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>无代码，只放证明</p><p><strong>假设仓库建在最优位置</strong>（必需有这个前提）时，左边有 $a$ 个商店，那么右边就有 $n - a$ 个商店，左边商店距离仓库的位置之和为 $p$ ，右边的商店距离仓库的位置之和为 $q$ 可得 $p + q$ 为所有商店到仓库的最小距离之和</p><p>现在将仓库向左移 $x$，可得<br>$p - ax + q + (n-a)x$<br>$ = p - ax + q + nx - ax$<br>$ = p + q + (n - 2a)x $</p><p>因为仓库之前是设在最优位置，所以 $n - 2a ≥ 0$ ，如果不满足这个条件，那么就和我们仓库建在最优位置的条件产生冲突，即 $p + q$ 就不是我们的所有商店到仓库的距离之和最小了。</p><p>此时，当 $a = \frac{n}{2}$ 时，得到最优答案。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>中位数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电影</title>
    <link href="/2022/01/15/%E7%94%B5%E5%BD%B1/"/>
    <url>/2022/01/15/%E7%94%B5%E5%BD%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h1><p>莫斯科正在举办一个大型国际会议，有 $n$ 个来自不同国家的科学家参会。</p><p>每个科学家都只懂得一种语言。</p><p>为了方便起见，我们把世界上的所有语言用 $1$ 到 $10^9$ 之间的整数编号。</p><p>在会议结束后，所有的科学家决定一起去看场电影放松一下。</p><p>他们去的电影院里一共有 $m$ 部电影正在上映，每部电影的语音和字幕都采用不同的语言。</p><p>对于观影的科学家来说，如果能听懂电影的语音，他就会很开心；如果能看懂字幕，他就会比较开心；如果全都不懂，他就会不开心。</p><p>现在科学家们决定大家看同一场电影。</p><p>请你帮忙选择一部电影，可以让观影很开心的人最多。</p><p>如果有多部电影满足条件，则在这些电影中挑选观影比较开心的人最多的那一部。</p><p><strong>输入格式</strong></p><p>第一行输入一个整数 $n$，代表科学家的数量。</p><p>第二行输入 $n$ 个整数 $a_1,a_2…a_n$，其中 $a_i$表示 第 $i$ 个科学家懂得的语言的编号。</p><p>第三行输入一个整数 $m$，代表电影的数量。</p><p>第四行输入 $m$ 个整数 $b_1,b_2…b_m$，其中 $b_i$ 表示第 $i$ 部电影的语音采用的语言的编号。</p><p>第五行输入 $m$ 个整数 $c_1,c_2…c_m$，其中 $c_i$表示第 $i$ 部电影的字幕采用的语言的编号。</p><p>请注意对于同一部电影来说，$b_i≠c_i$。</p><p>同一行内数字用空格隔开。</p><p><strong>输出格式</strong></p><p>输出一个整数，代表最终选择的电影的编号。电影编号 $1∼m$。</p><p>如果答案不唯一，输出任意一个均可。</p><p><strong>数据范围</strong></p><p>$1≤n,m≤200000$,<br>$1≤a_i,b_i,c_i≤10^9$</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>只考虑电影的语言和字幕是否和科学家会的语言一样，看到询问的数据范围 $2 \times 10^5$，而每个数的大小却是 $1 \times 10^9$ 那么久考虑使用离散化。</p><blockquote><p> 离散化是指，将一段稀疏的数据变成一段稠密的数据</p></blockquote><p>对应题意，有一个最简单的实现方法，假设会的语言编号为 2 8 1000 100000，那么就可以得到 $f_2 =  …,f_8 = …,f_{1000} = …,f_{100000}=…$ 这里的 $f_i$ 为每种语言有多少科学家会，于是我们询问时直接提取就好，但是有个问题 这里编号大小的数据范围为 $[1,10^9]$，直接开这么大的数组就会 MLE。于是考虑离散化</p><p>例如，假设我的原数组是 2 8 1000 100000，那么我的新数组就是 1 2 3 4，为了在询问原数组的数时能快速得到新数组的对应值，我们用另外一个数组来储存原数组 即 $a_i$，那么可得 $a_1 = 2,a_2 = 8, a_3 = 1000, a_4 = 100000$ ，该数组满足单调性，那么用二分在这个数组里查询就可以很快得到新数组的值（即查询的下标）。</p><p>我们的原问题也可以得到解决，此时我们的 $f_i$ 就变成了 $f_1 = …,f_2 = …,f_3 = …,f_4 = …$ ，离散化后的下标数据范围为 $[1, 2\times 10^5]$ ，很显然 这样开就不会MLE了。</p><p>既然不会 MLE 了，我们再来算下时间复杂度。假设总共有 $K$ 种语言，那么每次询问用二分来查询就是 $O(logK)$ 的复杂度，单独查询电影语言的总复杂度就是 $O(mlogK)$，而二分查询需要满足一定的二分性，且科学家的顺序并不影响我们之后的操作，所以我们统计科学家语言的时候只需要将其排序再统计，那么可得总复杂度就是 $O(nlogn +2mlogK )$ </p><p>这个时间复杂度是可以过的，即使写的杂糅点时间也绰绰有余。</p><p>看代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-comment">//不想用map和set 也不想记二分函数 那样就不会计算时间复杂度了</span><br><span class="hljs-comment">//代码写的有点复杂了，懒得优化 看个思路就好 自己写</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">200005</span>;<br><span class="hljs-keyword">int</span> arr[N], Sign[N], Newarr[N], RSign[N], answ[N];<br><span class="hljs-keyword">bool</span> Vis[N];<br><br><span class="hljs-keyword">int</span> tnt = <span class="hljs-number">1</span>, tot = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cheak</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-comment">//二分寻找离散化之前的原值</span><br><span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = tot;<br><span class="hljs-keyword">while</span>(r &gt;= l) &#123;<br><span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(x == Sign[mid]) <span class="hljs-keyword">return</span> mid;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; Sign[mid]) l = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>std::<span class="hljs-built_in">sort</span>(arr + <span class="hljs-number">1</span>, arr + <span class="hljs-number">1</span> + n);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">//统计每种语言有多少科学家会，离散化原数组</span><br><span class="hljs-keyword">if</span>(arr[i] == arr[i + <span class="hljs-number">1</span>]) Newarr[tnt]++;<br><span class="hljs-keyword">else</span> Newarr[tnt]++, tnt++;<br><br><span class="hljs-keyword">if</span>(arr[i] != arr[i + <span class="hljs-number">1</span>]) Sign[++tot] = arr[i];<br>&#125;<br><br><span class="hljs-keyword">int</span> m, ans = <span class="hljs-number">0</span>, ansx, maxx = <span class="hljs-number">0</span>, twt = <span class="hljs-number">0</span>; <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123; <span class="hljs-comment">//询问电影语言</span><br><span class="hljs-keyword">int</span> x;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x); RSign[i] = x;<br><br>ansx = <span class="hljs-built_in">cheak</span>(x); <span class="hljs-keyword">if</span>(ansx == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(maxx &lt; Newarr[ansx]) &#123; <br>        <span class="hljs-comment">//因为可能存在多个听得懂语言的科学家数量相同的电影 所以需要记录</span><br>maxx = Newarr[ansx];<br>ans = i;<br>twt = <span class="hljs-number">1</span>;<br>answ[twt] = i;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(maxx == Newarr[ansx]) &#123;<br>twt++;<br>answ[twt] = i;<br>&#125;<br>&#125; <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">0</span>) flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//如果所有科学家都听不懂，那么我们就标记 等会儿就只考虑看得懂</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= twt; i++) Vis[answ[i]] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//方便调用</span><br><br><span class="hljs-keyword">int</span> ansy, maxy = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123; <span class="hljs-comment">//询问电影字幕</span><br><span class="hljs-keyword">int</span> y;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;y);<br><br>ansy = <span class="hljs-built_in">cheak</span>(y); <span class="hljs-keyword">if</span>(ansy == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(flag &amp;&amp; maxy &lt;= Newarr[ansy]) maxy = Newarr[ansy], ans = i; <br><span class="hljs-keyword">if</span>(!flag &amp;&amp; Vis[i] &amp;&amp; maxy &lt;= Newarr[ansy]) &#123;<br>maxy = Newarr[ansy];<br>ans = i;<br>&#125;<br>&#125; <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, m); <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-comment">//如果没有一部电影是科学家们看得懂和听得懂的 我们就随便输出一个（也满足题意）</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二分</tag>
      
      <tag>离散化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最佳牛围栏</title>
    <link href="/2022/01/11/%E6%9C%80%E4%BD%B3%E7%89%9B%E5%9B%B4%E6%A0%8F/"/>
    <url>/2022/01/11/%E6%9C%80%E4%BD%B3%E7%89%9B%E5%9B%B4%E6%A0%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="最佳牛围栏"><a href="#最佳牛围栏" class="headerlink" title="最佳牛围栏"></a>最佳牛围栏</h1><p>农夫约翰的农场由 $N$ 块田地组成，每块地里都有一定数量的牛，其数量不会少于 $1$ 头，也不会超过 $2000$ 头。</p><p>约翰希望用围栏将一部分连续的田地围起来，并使得围起来的区域内每块地包含的牛的数量的平均值达到最大。</p><p>围起区域内至少需要包含 $F$ 块地，其中 $F$ 会在输入中给出。</p><p>在给定条件下，计算围起区域内每块地包含的牛的数量的平均值可能的最大值是多少。</p><p><strong>输入格式</strong></p><p>第一行输入整数 $N$ 和 $F$，数据间用空格隔开。</p><p>接下来 $N$ 行，每行输入一个整数，第 $i+1$ 行输入的整数代表第 $i$ 片区域内包含的牛的数目。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示平均值的最大值乘以 $1000$ 再 <strong>向下取整</strong> 之后得到的结果。</p><p><strong>数据范围</strong></p><p>$1≤N≤100000$<br>$1≤F≤N$</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">6 </span><br><span class="hljs-number">4</span><br><span class="hljs-number">2</span><br><span class="hljs-number">10</span><br><span class="hljs-number">3</span><br><span class="hljs-number">8</span><br><span class="hljs-number">5</span><br><span class="hljs-number">9</span><br><span class="hljs-number">4</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">6500</span><br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>① <strong>可能的最大值</strong>，抓住关键词，考虑是否可以用二分，假设存在某一个平均值满足题目条件，那么小于该值的平均值一定能满足题目条件，而大于该值的平均值不一定能满足题目条件，于是可得 可以用二分</p><p>② 为了快速判断某一区间的值是否大于我们二分的平均值，我们可以让每个数减去平均值，这样再将它们全部加起来就可以判断当前某一区间的平均值是否大于二分的平均值。</p><p>最后看代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">//前排提醒 更简单的可以看Yxc的代码</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100005</span>;<br><span class="hljs-keyword">int</span> arr[N];<br><span class="hljs-keyword">double</span> f[N];<br><br><span class="hljs-keyword">int</span> n, F;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cheak</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">//这里是②的实现</span><br>f[i] = f[i - <span class="hljs-number">1</span>] + arr[i] - x;<br>&#125;<br><br><span class="hljs-keyword">double</span> minv = <span class="hljs-number">1e9</span>; <span class="hljs-comment">//因为保证至少包含 F 块地，所以可以有F + 1， F + 2块，我们选个最优的即可</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = F; j &lt;= n; i++, j++) &#123; <span class="hljs-comment">//用双指针保证每次都是 F 块 用minv保证最小的是最优的</span><br>minv = std::<span class="hljs-built_in">min</span>(minv, f[i]);<br><span class="hljs-keyword">if</span>(f[j] - minv &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;F);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>&#125;<br><br><span class="hljs-keyword">double</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">100000</span>; <span class="hljs-comment">//二分</span><br><span class="hljs-keyword">while</span>(r - l &gt; <span class="hljs-number">1e-5</span>) &#123;<br><span class="hljs-keyword">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">cheak</span>(mid)) l = mid;<br><span class="hljs-keyword">else</span> r = mid;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (<span class="hljs-keyword">int</span>)(r * <span class="hljs-number">1000</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>前缀和</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最高的牛</title>
    <link href="/2022/01/11/%E6%9C%80%E9%AB%98%E7%9A%84%E7%89%9B/"/>
    <url>/2022/01/11/%E6%9C%80%E9%AB%98%E7%9A%84%E7%89%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="最高的牛"><a href="#最高的牛" class="headerlink" title="最高的牛"></a>最高的牛</h1><p>有 $N$ 头牛站成一行，被编队为 $1、2、3…N$，每头牛的身高都为整数。</p><p>当且仅当两头牛中间的牛身高都比它们矮时，两头牛方可看到对方。</p><p>现在，我们只知道其中最高的牛是第 $P$ 头，它的身高是 $H$ ，剩余牛的身高未知。</p><p>但是，我们还知道这群牛之中存在着 $M$ 对关系，每对关系都指明了某两头牛 $A$ 和 $B$ 可以相互看见。</p><p>求每头牛的身高的最大可能值是多少。</p><p><strong>输入格式</strong></p><p>第一行输入整数 $N,P,H,M$，数据用空格隔开。</p><p>接下来 $M$ 行，每行输出两个整数 $A$ 和 $B$，代表牛 $A$ 和牛 $B$ 可以相互看见，数据用空格隔开。</p><p><strong>输出格式</strong></p><p>一共输出 $N$ 行数据，每行输出一个整数。</p><p>第 $i$ 行输出的整数代表第 $i$ 头牛可能的最大身高。</p><p><strong>数据范围</strong></p><p>$1≤N≤10000$,<br>$1≤H≤1000000$,<br>$1≤A,B≤10000$,<br>$0≤M≤10000$</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">9 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs">5<br>4<br>5<br>3<br>4<br>4<br>5<br>5<br>5<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>此题中给出的关系对可能存在重复</li></ul><p><strong>解析</strong></p><p>需要用到知识点 差分数组 （复习）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">有数组 A[<span class="hljs-number">1</span>] A[<span class="hljs-number">2</span>] A[<span class="hljs-number">3</span>] A[<span class="hljs-number">4</span>]<br>差分数组 B[i] = A[i] - A[i - <span class="hljs-number">1</span>]<br>可得 A[i] = B[<span class="hljs-number">1</span>] + B[<span class="hljs-number">2</span>] + B[<span class="hljs-number">3</span>] + .... + B[i]<br></code></pre></td></tr></table></figure><p>由问题可得，我们需要始终让数组 $a_n$ 的某区间 $[l,r]$ 中，$a_l$ 与 $a_r$ 的值在这个区间最大。</p><p>那很简单，让每次的询问中使 $[l+1,r-1]$ 的区间内所有数 $-1$ 就好，这样就能保证 $a_l$ 与 $a_r$ 在 $[l,r]$ 中最大，且满足我们尽可能让每头牛的身高最高的条件。</p><p>这里的区间数作加减，用差分数组完成即可。</p><p>最后就是 <strong>此题中给出的关系对可能存在重复</strong> 的条件，我们只需要排序一下，看看当前的区间是否和上一个区间不同就好。（因为 $1≤N≤10000$，所以没有考虑用二维数组标记 64MB会MLE，但题解里似乎有用 bool 数组进行标记的）</p><p>剩下的看代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-comment">//前排提醒 更简单的看yxc的代码</span><br><span class="hljs-keyword">int</span> n, p, h, m;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10005</span>;<br>std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; arr[N];<br><span class="hljs-keyword">int</span> B[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;a, std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;b)</span> </span>&#123; <span class="hljs-comment">//用pair排序得构造</span><br><span class="hljs-keyword">if</span>(a.first != b.first) <span class="hljs-keyword">return</span> a.first &lt; b.first;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.second &lt; b.second;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;p, &amp;h, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;arr[i].first, &amp;arr[i].second);<br><span class="hljs-keyword">if</span>(arr[i].first &gt; arr[i].second) std::<span class="hljs-built_in">swap</span>(arr[i].first, arr[i].second);<br>&#125; <span class="hljs-comment">//保证一定是左区间小于右区间</span><br><br>std::<span class="hljs-built_in">sort</span>(arr + <span class="hljs-number">1</span>, arr + <span class="hljs-number">1</span> + m, cmp);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123; <span class="hljs-comment">//如果相同就跳过，不同就进行区间操作</span><br><span class="hljs-keyword">if</span>(arr[i].first == arr[i - <span class="hljs-number">1</span>].first &amp;&amp; arr[i].second == arr[i - <span class="hljs-number">1</span>].second) <span class="hljs-keyword">continue</span>;<br>B[arr[i].first + <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>;<br>B[arr[i].second] += <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">int</span> ans = h;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>ans = ans + B[i];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>&#125; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意注意</strong></p><p>我只说明了 $[l + 1,r - 1]$ 上 $-1$ 的方法的最优性，没有证明其正确性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">若存在数据<br><span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-number">3</span> <span class="hljs-number">6</span><br>则由方法可得<br><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br>并不满足 <span class="hljs-number">3</span> <span class="hljs-number">6</span> 的询问，但这并不能说明方法的错误，只是因为这种数据不可能得到一个正确解<br>所以为了保证数据的正确性 若出现询问区间交叉的情况，设不合理的区间为 [l, r]<br>那么[l, r]一定会再次进行询问，直到原来的两次询问都为合法询问（满足题意要求的正确答案）为止<br>所以可以得到我们方法一定是正确的<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>差分数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>增减序列</title>
    <link href="/2022/01/10/%E5%A2%9E%E5%87%8F%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/10/%E5%A2%9E%E5%87%8F%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="增减序列"><a href="#增减序列" class="headerlink" title="增减序列"></a>增减序列</h1><p>给定一个长度为 $n$ 的数列 $a_1,a_2,…,a_n$，每次可以选择一个区间 $[l,r]$，使下标在这个区间内的数都加一或者都减一。</p><p>求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。</p><p><strong>输入格式</strong></p><p>第一行输入正整数 $n$。</p><p>接下来 $n$ 行，每行输入一个整数，第 $i+1$ 行的整数代表 $ai$。</p><p><strong>输出格式</strong></p><p>第一行输出最少操作次数。</p><p>第二行输出最终能得到多少种结果。</p><p><strong>数据范围</strong></p><p>$1≤n≤10^5$,<br>$0≤a_i&lt;2147483648$</p><p><strong>输入样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">4<br>1<br>1<br>2<br>2<br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>需要用到知识点 差分数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">有数组 A[<span class="hljs-number">1</span>] A[<span class="hljs-number">2</span>] A[<span class="hljs-number">3</span>] A[<span class="hljs-number">4</span>]<br>差分数组 B[i] = A[i] - A[i - <span class="hljs-number">1</span>]<br>可得 A[i] = B[<span class="hljs-number">1</span>] + B[<span class="hljs-number">2</span>] + B[<span class="hljs-number">3</span>] + .... + B[i]<br></code></pre></td></tr></table></figure><p>含义：原数组 $A_i$ 是差分数组 $B_i$ 的前 $i$ 项和</p><p>知道知识点我们来看题</p><p>首先需要实现，快速在 $[l,r]$ 区间内进行加减，根据差分数组的定义，在原数组 $A_i$ 的 $[l,r]$ 上作加减 就相当于在差分数组 $B_i$ 的 $B_l$ 与 $B_{r+1}$ 上作加减</p><p>比如样例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A_i <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br>B_i <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br>在[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]上 +<span class="hljs-number">1</span>，则<br>A_i <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br>B_i <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> (B_1 + <span class="hljs-number">1</span>, B_3 - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>好了，已经快速解决 $[l,r]$ 上作加减的问题，就可以来看题目的要求了</p><p>① 求最少的操作次数</p><p>② 输出最终能得到多少种结果</p><p>首先来解决①，我们的目的是 <strong>让差分数组除 $B_1$ 外的所有数都变成0</strong>，那么我们只需要让差分数组 <strong>负的加，正的减</strong> 就可以保证每次的选择都是最优选择，这个问题很好解决 一个循环即可。</p><p>但每次肯定不会正好减到 0，那我们只需要把多出来全部加到 $B_1$ 就好，这样也满足我们的目的。</p><p>然后来解决②，考虑①的最后一步，我们除了将多出来的移到 $B_1$，当然还可以移到 $B_{n+1}$，即将多出来的数再 <strong>加一减一</strong> 变成0（这里可以理解成在自己[l == r]上操作，也可以理解为在整个差分数组外还有一个规则外的区域），那么只需要多出来几就加上几就好（每个数都有两种选择，加到 $B_1$ 上 或者 不加到 $B_1$ 上）</p><p>看代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100005</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> arr[N], g[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;arr[i]);<br>g[i] = arr[i] - arr[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">//差分数组</span><br>&#125;<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> tnt = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span>(tnt &gt; <span class="hljs-number">0</span> &amp;&amp; g[i] &lt; <span class="hljs-number">0</span>) ans = ans + std::<span class="hljs-built_in">min</span>(tnt, std::<span class="hljs-built_in">abs</span>(g[i])), tnt = tnt + g[i]; <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tnt &lt; <span class="hljs-number">0</span> &amp;&amp; g[i] &gt; <span class="hljs-number">0</span>) ans = ans + std::<span class="hljs-built_in">min</span>(std::<span class="hljs-built_in">abs</span>(tnt), g[i]), tnt = tnt + g[i]; <br>        <span class="hljs-comment">//异号的情况 说明有正负出现 正的加，负的减就好</span><br><span class="hljs-keyword">else</span> tnt += g[i]; <span class="hljs-comment">//同号的情况 那么记录起来就好</span><br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans + std::<span class="hljs-built_in">abs</span>(tnt));<br>    <span class="hljs-comment">//最优情况（负的加，正的减   +    多出来的数（可能是负数，记得取绝对值））</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, std::<span class="hljs-built_in">abs</span>(tnt) + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//讨论多少种情况 详细看上面解析</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>差分数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1月番剧表</title>
    <link href="/2022/01/08/1%E6%9C%88%E7%95%AA%E5%89%A7%E8%A1%A8/"/>
    <url>/2022/01/08/1%E6%9C%88%E7%95%AA%E5%89%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="番剧自追表"><a href="#番剧自追表" class="headerlink" title="番剧自追表"></a>番剧自追表</h1><p><strong>前排提示：只含自己感兴趣的番，可能不含所有的1月新番</strong></p><h3 id="指名！-（CUE-）"><a href="#指名！-（CUE-）" class="headerlink" title="指名！ （CUE!）"></a>指名！ （CUE!）</h3><p><img src="https://c2.im5i.com/2022/01/08/Ud272.jpg" alt="Ud272.jpg"></p><p>声优们的故事，应该和往常每个季度的偶像番定位类似，日常 + 励志，本人十分推荐。</p><p>PV表现优秀，片段就有让人起鸡皮疙瘩的感觉。</p><h3 id="我是川尻小玉～生活黑客的糜烂生活～（あたしゃ川尻こだまだよ～デンジャラスライフハッカーのただれた生活～）"><a href="#我是川尻小玉～生活黑客的糜烂生活～（あたしゃ川尻こだまだよ～デンジャラスライフハッカーのただれた生活～）" class="headerlink" title="我是川尻小玉～生活黑客的糜烂生活～（あたしゃ川尻こだまだよ～デンジャラスライフハッカーのただれた生活～）"></a>我是川尻小玉～生活黑客的糜烂生活～（あたしゃ川尻こだまだよ～デンジャラスライフハッカーのただれた生活～）</h3><p><img src="https://c2.im5i.com/2022/01/08/UdWBl.jpg" alt="UdWBl.jpg"></p><p>泡面番，但是却是单口相声（</p><p>配色挺像多娜多娜，看PV感觉就像在玩dlc…，唯一比较期待的地方是声优：悠木碧（那这单口相声质量就有打底了，毕竟蜘蛛子的单口相声有多优秀就不必我多说了）</p><p>定位是搞笑吧，但是单口相声可能会涉及点其他的，期待值++</p><h3 id="平凡职业成就世界最强-第二季（ありふれた職業で世界最強-2nd-season）"><a href="#平凡职业成就世界最强-第二季（ありふれた職業で世界最強-2nd-season）" class="headerlink" title="平凡职业成就世界最强 第二季（ありふれた職業で世界最強 2nd season）"></a>平凡职业成就世界最强 第二季（ありふれた職業で世界最強 2nd season）</h3><p><img src="https://c2.im5i.com/2022/01/08/UdRVP.jpg" alt="UdRVP.jpg"></p><p>经典续作了属于是，第一季炸成那样了还能出第二季，看起来本身的剧本质量不错。但是我看了PV，还是熟悉的3d，还是经典的特效糊脸….差点给我整笑了，本来想定义异世界冒险番的，但还是定义成异世界老婆番可能受众会更多一点。</p><h3 id="擅长捉弄的高木同学-第三季（からかい上手の高木さん③）"><a href="#擅长捉弄的高木同学-第三季（からかい上手の高木さん③）" class="headerlink" title="擅长捉弄的高木同学 第三季（からかい上手の高木さん③）"></a>擅长捉弄的高木同学 第三季（からかい上手の高木さん③）</h3><p><img src="https://c2.im5i.com/2022/01/08/UdTQn.jpg" alt="UdTQn.jpg"></p><p>依旧是本季度天花板级别的狗粮番，但个人并不太喜欢这类作品，因为逢坂大河是我老婆，不接受反驳。（恋爱番看一部就够了，不能接受天天换老婆）</p><h3 id="更衣人偶坠入爱河（その着せ替え人形は恋をする）"><a href="#更衣人偶坠入爱河（その着せ替え人形は恋をする）" class="headerlink" title="更衣人偶坠入爱河（その着せ替え人形は恋をする）"></a>更衣人偶坠入爱河（その着せ替え人形は恋をする）</h3><p><img src="https://c2.im5i.com/2022/01/08/UdXY7.jpg" alt="UdXY7.jpg"></p><p>男主给女主做cos服，女主很可爱，但男主是直男性冷淡…<del>看来作者只想画衣服</del>。这番看女主穿各种cos服就行了（萌混过关）估计就是养两集，看一次的这种。PV表现力优秀，经费都在女主身上。</p><h3 id="彩绿（イロドリミドリ）"><a href="#彩绿（イロドリミドリ）" class="headerlink" title="彩绿（イロドリミドリ）"></a>彩绿（イロドリミドリ）</h3><p><img src="https://c2.im5i.com/2022/01/08/Udnzj.jpg" alt="Udnzj.jpg"></p><p>乐队番，但是却是泡面番（</p><p>国内没人买，但是有汉化组做了汉化，b站上能看。</p><p>每个季度的这种番我都会看，所以即使是泡面番我也会看滴（</p><h3 id="东方少年（オリエント）"><a href="#东方少年（オリエント）" class="headerlink" title="东方少年（オリエント）"></a>东方少年（オリエント）</h3><p><img src="https://c2.im5i.com/2022/01/08/UdYTD.jpg" alt="UdYTD.jpg"></p><p>双男主，又是砍鬼，PV表现优秀 但实际的第一集的内容却并不好，剧本过于老套 并且没有大量的经费支持，毕竟热血打斗番没有经费… 确实是一言难尽了</p><h3 id="ガル学。II～Lucky-Stars～"><a href="#ガル学。II～Lucky-Stars～" class="headerlink" title="ガル学。II～Lucky Stars～"></a>ガル学。II～Lucky Stars～</h3><p><img src="https://c2.im5i.com/2022/01/08/Ud3NS.jpg" alt="Ud3NS.jpg"></p><p>偶像番哒，但看了PV觉得不如第一季，而且这个画风总有一股在看游戏王的感觉..就感觉女主下一秒就准备掏出战斗盘进行决斗了</p><h3 id="JOJO的奇妙冒险-石之海"><a href="#JOJO的奇妙冒险-石之海" class="headerlink" title="JOJO的奇妙冒险 石之海"></a>JOJO的奇妙冒险 石之海</h3><p><img src="https://c2.im5i.com/2022/01/08/UdIbL.jpg" alt="UdIbL.jpg"></p><p>看就完了</p><h3 id="女孩的钓鱼慢活（スローループ）"><a href="#女孩的钓鱼慢活（スローループ）" class="headerlink" title="女孩的钓鱼慢活（スローループ）"></a>女孩的钓鱼慢活（スローループ）</h3><p><img src="https://c2.im5i.com/2022/01/08/Udmhq.jpg" alt="Udmhq.jpg"></p><p>一直在说芳文社要出一部钓鱼的作品，这不就来了吗！</p><p>我们口号是：</p><p>萝莉！萝莉！萝莉！！！</p><p>钓鱼！钓鱼！钓鱼！！！</p><p>百合！百合！百合！！！</p><p>这才是这个季度的猛男番好吗？认准工牌：芳文社</p><h3 id="TRIBE-NINE（トライブナイン）"><a href="#TRIBE-NINE（トライブナイン）" class="headerlink" title="TRIBE NINE（トライブナイン）"></a>TRIBE NINE（トライブナイン）</h3><p><img src="https://c2.im5i.com/2022/01/08/UfGol.jpg" alt="UfGol.jpg"></p><p>小高的又一部作品，上一部恶心完大家了 这一部看看小高又给大家整什么好活来了</p><p>赛博朋克的整体风格，看PV应该是能看下去的，就看剧本怎么样了</p><h3 id="少女前线"><a href="#少女前线" class="headerlink" title="少女前线"></a>少女前线</h3><p><img src="https://c2.im5i.com/2022/01/08/UdZmt.jpg" alt="UdZmt.jpg"></p><p>手游番，但是少女前线本身的剧情就刀..，这…</p><p>看PV表现力还不错，这是开始给少女前线2预热了吗.</p><h3 id="秘密内幕～女子警察的逆袭～（ハコヅメ～交番女子の逆襲～）"><a href="#秘密内幕～女子警察的逆袭～（ハコヅメ～交番女子の逆襲～）" class="headerlink" title="秘密内幕～女子警察的逆袭～（ハコヅメ～交番女子の逆襲～）"></a>秘密内幕～女子警察的逆袭～（ハコヅメ～交番女子の逆襲～）</h3><p><img src="https://c2.im5i.com/2022/01/08/UdxBm.jpg" alt="UdxBm.jpg"></p><p>这个月的搞笑番担当，听过真人版非常火，找个时间去补一下。PV表现还挺好的，况且这个封面上两只猩猩整体就变得奇怪了吧喂</p><h3 id="室内足球少年"><a href="#室内足球少年" class="headerlink" title="室内足球少年!!!!!"></a>室内足球少年!!!!!</h3><p><img src="https://c2.im5i.com/2022/01/08/Ud8ns.jpg" alt="Ud8ns.jpg"></p><p>来了，这个季度的运动番。是双男主，而且人设和小排球一模一样xxx</p><p>但是看了PV有3d的进球桥段，虽说封面很华丽..但实际表现我感觉蛮不妙的，运动番还是要经费高点才好看啊….只能说期待吧</p><h3 id="公主连结-Re-Dive-第二季"><a href="#公主连结-Re-Dive-第二季" class="headerlink" title="公主连结 Re:Dive 第二季"></a>公主连结 Re:Dive 第二季</h3><p><img src="https://c2.im5i.com/2022/01/08/UdAMQ.jpg" alt="UdAMQ.jpg"></p><p>又开始送钻了，这次复刻池子的春猫和春妈应该都能拿到了，不会吧 不会吧，不会真的有人去看第二季吧，我期待第二季是因为他送的真的是太多了（</p><p>国服的第一季在游戏里已经完结了，打完了霸瞳皇帝。如果对剧情感兴趣的 但却没有玩游戏，建议直接去看b站上整理的游戏内剧情（毕竟pcr本体是个看番软件…）</p><h3 id="里亚德录大地-（リアデイルの大地にて）"><a href="#里亚德录大地-（リアデイルの大地にて）" class="headerlink" title="里亚德录大地 （リアデイルの大地にて）"></a>里亚德录大地 （リアデイルの大地にて）</h3><p><img src="https://c2.im5i.com/2022/01/08/UdeV3.jpg" alt="UdeV3.jpg"></p><p>异世界穿越番，看PV没看懂什么意思… 异世界搞笑番，而且是凤傲天，原画师只有一人..我的评价是看个乐呵，能动就行。</p><h3 id="白领羽球部（リーマンズクラブ）"><a href="#白领羽球部（リーマンズクラブ）" class="headerlink" title="白领羽球部（リーマンズクラブ）"></a>白领羽球部（リーマンズクラブ）</h3><p><img src="https://c2.im5i.com/2022/01/08/UdzWy.jpg" alt="UdzWy.jpg"></p><p>竟然不是高中生了？！开始给成年人注入鸡血了是吧，PV的运动表现力十足，画风很干净，绝对值得期待！</p><h3 id="瓦尼塔斯的手札-第二季（ヴァニタスの手記-第2クール）"><a href="#瓦尼塔斯的手札-第二季（ヴァニタスの手記-第2クール）" class="headerlink" title="瓦尼塔斯的手札 第二季（ヴァニタスの手記 第2クール）"></a>瓦尼塔斯的手札 第二季（ヴァニタスの手記 第2クール）</h3><p><img src="https://c2.im5i.com/2022/01/08/Ud0zO.jpg" alt="Ud0zO.jpg"></p><p>我个人没看过第一季，但是看第二季的PV表现还蛮不错的，有时间去补一下第一季。</p><h3 id="佐佐木与宫野（佐々木と宮野）"><a href="#佐佐木与宫野（佐々木と宮野）" class="headerlink" title="佐佐木与宫野（佐々木と宮野）"></a>佐佐木与宫野（佐々木と宮野）</h3><p><img src="https://c2.im5i.com/2022/01/08/UdaNR.jpg" alt="UdaNR.jpg"></p><p>女性向作品，攻受分明，听腐女同志说很甜..</p><h3 id="天才王子的赤字国家振兴术（天才王子の赤字国家再生術）"><a href="#天才王子的赤字国家振兴术（天才王子の赤字国家再生術）" class="headerlink" title="天才王子的赤字国家振兴术（天才王子の赤字国家再生術）"></a>天才王子的赤字国家振兴术（天才王子の赤字国家再生術）</h3><p><img src="https://c2.im5i.com/2022/01/08/Udpm4.jpg" alt="Udpm4.jpg"></p><p>故意用错误的策略却导致了十分正确的结果，太期待这部番了 看PV都把我乐的要死 腹肌锻炼器，肌肉撕裂装置（</p><h3 id="失格纹的最强贤者-世界最强贤者为了变得更强转生"><a href="#失格纹的最强贤者-世界最强贤者为了变得更强转生" class="headerlink" title="失格纹的最强贤者 世界最强贤者为了变得更强转生"></a>失格纹的最强贤者 世界最强贤者为了变得更强转生</h3><p><img src="https://c2.im5i.com/2022/01/08/Ud4td.jpg" alt="Ud4td.jpg"></p><p>超位起手，龙傲天异世界作品，看了PV感觉和那个魔王重生差不多… 就看个开头爽爽，按PV的表现来看，我觉得中后期大概率会崩..</p><h3 id="怪人开发部的黑井津"><a href="#怪人开发部的黑井津" class="headerlink" title="怪人开发部的黑井津"></a>怪人开发部的黑井津</h3><p><img src="https://c2.im5i.com/2022/01/08/UdOJG.jpg" alt="UdOJG.jpg"></p><p>和之前那个动物开发部一样，动物折磨完了来折磨魔物了是吧（</p><p>搞笑番，期待</p><h3 id="明日酱的水手服"><a href="#明日酱的水手服" class="headerlink" title="明日酱的水手服"></a>明日酱的水手服</h3><p><img src="https://c2.im5i.com/2022/01/08/UfgJn.jpg" alt="UfgJn.jpg"></p><p>女主超可爱超色气！！！wwww 爱上啦！！</p><p>还有名场面，同学剪完脚指甲然后去闻，哈哈哈哈哈 足控表示一脸满足</p><h3 id="最游记-RELOAD-ZEROIN"><a href="#最游记-RELOAD-ZEROIN" class="headerlink" title="最游记 RELOAD -ZEROIN-"></a>最游记 RELOAD -ZEROIN-</h3><p><img src="https://c2.im5i.com/2022/01/08/UdMhW.jpg" alt="UdMhW.jpg"></p><p>文艺复兴，重置版。参考的西游记，老版本没看过，不过PV表现蛮好的（这唐僧用枪），还有关西腔，比较期待吧</p><h3 id="东京24区"><a href="#东京24区" class="headerlink" title="东京24区"></a>东京24区</h3><p><img src="https://c2.im5i.com/2022/01/08/Udknz.jpg" alt="Udknz.jpg"></p><p>看PV没看懂这番..但男主追火车救妹子实在是震惊我，似乎是某个视频能给予人能力，男主三人被赋予了能力也同时赋予了使命，感觉表现力还行，但该公司这个季度还接下来另外两部作品，看发挥了 希望不要外包</p><h3 id="杀爱（殺し愛）"><a href="#杀爱（殺し愛）" class="headerlink" title="杀爱（殺し愛）"></a>杀爱（殺し愛）</h3><p><img src="https://c2.im5i.com/2022/01/08/Uf1M5.jpg" alt="Uf1M5.jpg"></p><p>看PV的标签是悬疑，但警方的妹子和犯罪者好上了？男主还是个眯眯眼，要嗑起来了吗</p><h3 id="现实主义勇者的王国再建记-第二部"><a href="#现实主义勇者的王国再建记-第二部" class="headerlink" title="现实主义勇者的王国再建记 第二部"></a>现实主义勇者的王国再建记 第二部</h3><p><img src="https://c2.im5i.com/2022/01/08/UfhW8.jpg" alt="UfhW8.jpg"></p><p>那个国王又送国又送女儿给男主的番？PV这人物看的一点都不舒服，异世界种田后宫番，PV除了人物观感不太行，其余的都还好</p><h3 id="与成为异世界美少女的大叔一起（異世界美少女受肉おじさんと）"><a href="#与成为异世界美少女的大叔一起（異世界美少女受肉おじさんと）" class="headerlink" title="与成为异世界美少女的大叔一起（異世界美少女受肉おじさんと）"></a>与成为异世界美少女的大叔一起（異世界美少女受肉おじさんと）</h3><p><img src="https://c2.im5i.com/2022/01/08/UfQd6.jpg" alt="UfQd6.jpg"></p><p>性转题材异世界穿越无厘头搞笑番，哈哈哈哈PV都把我笑死了，非常推荐</p><h3 id="终末的后宫"><a href="#终末的后宫" class="headerlink" title="终末的后宫"></a>终末的后宫</h3><p><img src="https://c2.im5i.com/2022/01/08/Ufw0U.jpg" alt="Ufw0U.jpg"></p><p>极度不推荐，是那种设定是里番设定 但是却打擦边球的作品，个人觉得是垃圾中的垃圾</p><h3 id="蔷薇王的葬队（薔薇王の葬列）"><a href="#蔷薇王的葬队（薔薇王の葬列）" class="headerlink" title="蔷薇王的葬队（薔薇王の葬列）"></a>蔷薇王的葬队（薔薇王の葬列）</h3><p><img src="https://c2.im5i.com/2022/01/08/UfqSw.jpg" alt="UfqSw.jpg"></p><p>剧情大概是男主天生有两种性别，然后男主因为某些原因被卷入了争夺王位的战争漩涡之中。</p><p>画风更偏美男子，我觉得应该是女性向作品，个人不太感冒。</p><h3 id="自称贤者弟子的贤者（賢者の弟子を名乗る賢者）"><a href="#自称贤者弟子的贤者（賢者の弟子を名乗る賢者）" class="headerlink" title="自称贤者弟子的贤者（賢者の弟子を名乗る賢者）"></a>自称贤者弟子的贤者（賢者の弟子を名乗る賢者）</h3><p><img src="https://c2.im5i.com/2022/01/08/Uf6xJ.jpg" alt="Uf6xJ.jpg"></p><p>PV开幕雷击，“老夫真可爱”。在某个虚拟游戏中（<del>SAO</del>），某一天原本建国级别的玩家（老爷爷）突然发现无法退出游戏，并且这个世界已经走过了30年，而且自己变成了幼小而美丽的少女（怎么我就遇不上这种事？） 因此展开的冒险。</p><p>感觉是异世界喜剧，毕竟老爷爷都算建国级别的贤者了，出门即毕业。但是动漫这动作…老爷爷也有童心是吧。</p><h3 id="进击的巨人-最终季-Part-2"><a href="#进击的巨人-最终季-Part-2" class="headerlink" title="进击的巨人 最终季 Part.2"></a>进击的巨人 最终季 Part.2</h3><p><img src="https://c2.im5i.com/2022/01/08/UfvtZ.jpg" alt="UfvtZ.jpg"></p><p>这位更是重量级的，这波啊 这波叫諫山創背刺mappa</p><h3 id="食锈末世录"><a href="#食锈末世录" class="headerlink" title="食锈末世录"></a>食锈末世录</h3><p><img src="https://c2.im5i.com/2022/01/08/UfSw1.jpg" alt="UfSw1.jpg"></p><p>电击文库的轻小说改编 热血少年漫，看了PV 感觉可以期待一发</p><p><strong>里番推荐</strong></p><p>是否已满18岁？ <a class="btn" href="https://lovehshan.top/2022/01/08/%E4%B8%80%E6%9C%88%E9%87%8C%E7%95%AA%E6%8E%A8%E8%8D%90/" title="里番推荐">是，我已满18岁</a></p>]]></content>
    
    
    <categories>
      
      <category>番剧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>番剧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>激光炸弹</title>
    <link href="/2022/01/08/%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9/"/>
    <url>/2022/01/08/%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="激光炸弹"><a href="#激光炸弹" class="headerlink" title="激光炸弹"></a>激光炸弹</h1><p>地图上有 $N$ 个目标，用整数 $X_i,Y_i$ 表示目标在地图上的位置，每个目标都有一个价值 $W_i$。</p><p><strong>注意</strong>：不同目标可能在同一位置。</p><p>现在有一种新型的激光炸弹，可以摧毁一个包含 $R×R$ 个位置的正方形内的所有目标。</p><p>激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 $x，y$ 轴平行。</p><p>求一颗炸弹最多能炸掉地图上总价值为多少的目标。</p><p><strong>输入格式</strong></p><p>第一行输入正整数 $N$ 和 $R$，分别代表地图上的目标数目和正方形的边长，数据用空格隔开。</p><p>接下来 $N$ 行，每行输入一组数据，每组数据包括三个整数 $X_i,Y_i,W_i$，分别代表目标的 $x$ 坐标，$y$ 坐标和价值，数据用空格隔开。</p><p><strong>输出格式</strong></p><p>输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。</p><p><strong>数据范围</strong></p><p>$0≤R≤10^9$<br>$0&lt;N≤10000$<br>$0≤X_i,Y_i≤5000$<br>$0≤W_i≤1000$</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>一个前缀和的小运用，因为本题只有一个炸弹，所以我们只需要 <strong>贪心</strong> 选择一个 $R\times R$ 大小区域内的价值总数最高的即可</p><p>那么就有一个疑问，如何快速求得一个 $R\times R$ 大小区域的价值总数？小技巧 <strong>前缀和</strong>，因为你想快速询问某个区域内的价值总数 最快的方式就是先将里面的所有数加起来放到一个点上，这样无论是询问和扩展都只用询问这个点即可。</p><p>知道这个方法，接下来的事情就非常简单了，如果当前询问的点并没有超过R，那么直接与答案求最大值，如果当前询问的点长或宽超过了R，那么就将超过的部分在前面截掉，因为我们用的前缀和，所以在截掉这里的计算也十分的便捷。</p><p>但这里注意，如果长和宽都超过了R，同时截掉长和宽多出的一部分就会使这两者重叠的一部分被减掉两次，所以在这里处理的时候需要再加上。</p><p>详细看代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">int</span> N, R;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Maxn = <span class="hljs-number">5005</span>;<br><span class="hljs-keyword">int</span> Map[Maxn][Maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">memset</span>(Map, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Map));<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;N, &amp;R); <span class="hljs-keyword">int</span> mx = <span class="hljs-number">0</span>, my =<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br><span class="hljs-keyword">int</span> x, y, w;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;w);<br>Map[x + <span class="hljs-number">1</span>][y + <span class="hljs-number">1</span>] += w;<br>mx = std::<span class="hljs-built_in">max</span>(mx, x + <span class="hljs-number">1</span>);<br>my = std::<span class="hljs-built_in">max</span>(my, y + <span class="hljs-number">1</span>); <span class="hljs-comment">//因为防止 -1 会变成负数，我这里 +1</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= mx; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= my; j++) &#123;<br>Map[i][j] = Map[i - <span class="hljs-number">1</span>][j] + Map[i][j - <span class="hljs-number">1</span>] - Map[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + Map[i][j];<br>&#125;<br>&#125; <span class="hljs-comment">//前缀和计算</span><br><br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= mx; i++) &#123; <span class="hljs-comment">//四种情况分别讨论</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= my; j++) &#123;<br><span class="hljs-keyword">if</span>(i &lt;= R &amp;&amp; j &lt;= R) ans = std::<span class="hljs-built_in">max</span>(ans, Map[i][j]);<br><span class="hljs-keyword">if</span>(i &gt; R &amp;&amp; j &lt;= R) ans = std::<span class="hljs-built_in">max</span>(ans, Map[i][j] - Map[i - R][j]);<br><span class="hljs-keyword">if</span>(i &lt;= R &amp;&amp; j &gt; R) ans = std::<span class="hljs-built_in">max</span>(ans, Map[i][j] - Map[i][j - R]);<br><span class="hljs-keyword">if</span>(i &gt; R &amp;&amp; j &gt; R) ans = std::<span class="hljs-built_in">max</span>(ans, Map[i][j] - Map[i - R][j] - Map[i][j - R] + Map[i - R][j - R]); <span class="hljs-comment">//这里要加上重叠的部分 因为减了两次</span><br>&#125;<br>&#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分形之城</title>
    <link href="/2022/01/08/%E5%88%86%E5%BD%A2%E4%B9%8B%E5%9F%8E/"/>
    <url>/2022/01/08/%E5%88%86%E5%BD%A2%E4%B9%8B%E5%9F%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="分形之城"><a href="#分形之城" class="headerlink" title="分形之城"></a>分形之城</h1><p>城市的规划在城市建设中是个大问题。</p><p>不幸的是，很多城市在开始建设的时候并没有很好的规划，城市规模扩大之后规划不合理的问题就开始显现。</p><p>而这座名为 Fractal 的城市设想了这样的一个规划方案，如下图所示：</p><p><img src="https://s4.ax1x.com/2022/01/08/7ChfRx.png" alt="city.png"></p><p>当城区规模扩大之后，Fractal 的解决方案是把和原来城区结构一样的区域按照图中的方式建设在城市周围，提升城市的等级。</p><p>对于任意等级的城市，我们把正方形街区从左上角开始按照道路标号。</p><p>虽然这个方案很烂，Fractal 规划部门的人员还是想知道，如果城市发展到了等级 $N$，编号为 $A$ 和 $B$ 的两个街区的直线距离是多少。</p><p>街区的距离指的是街区的中心点之间的距离，每个街区都是边长为 $10$ 米的正方形。</p><p><strong>输入格式</strong></p><p>第一行输入正整数 $n$，表示测试数据的数目。</p><p>以下 $n$ 行，输入 $n$ 组测试数据，每组一行。</p><p>每组数据包括三个整数 $N,A,B$，表示城市等级以及两个街区的编号，整数之间用空格隔开。</p><p><strong>输出格式</strong></p><p>一共输出 $n$ 行数据，每行对应一组测试数据的输出结果，结果四舍五入到整数。</p><p><strong>数据范围</strong></p><p>$1≤N≤31$,<br>$1≤A,B≤2^{2N}$,<br>$1≤n≤1000$</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">16</span> <span class="hljs-number">1</span> <br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">33</span> <br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><br><span class="hljs-symbol">30 </span><br><span class="hljs-symbol">50 </span><br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>大模拟题，思路简单</p><p>首先解决三个问题</p><p>①：如何从 [等级一] 的图像变化成 [等级二] 的图像</p><p>②：给你 [等级二] 图像中的某个点，如何找出该点在 [等级一] 图像中的对应点</p><p>③： 如何将上面的思路运用到更高等级的图像中</p><p>先解决 ①</p><p>懒，不想画图，给一张写题的草稿图，请自行找张纸根据我说的一边画一边看</p><p><img src="https://s4.ax1x.com/2022/01/08/7Ch6Z4.jpg"></p><p>我简单的令 等级一的图像 为 1图，等级二的图像 为 2图。将 2图 以四个房子为一个象限，图像的中点为原点，右为正x，上位正y 作一个坐标轴。取出 2图 中的四个象限图像，以 1图 样式摆放。</p><p>此时我们可以得到 4个4方格图像，分别代表的是 2图 的 “第一象限” “第二象限” “第三象限” 第四象限“</p><p>此时再以图像的中点为原点，右为正x，上为正y 作一个坐标轴，可以得到四个点分别在四个象限的图像。</p><p>此时 我们将四个图像的各编号以从小到大的顺序重新编号为 1、2、3、4，再将这四个图像与 1图 作比较。</p><p><strong>这里挑一个最难的说</strong> </p><p>第二象限图像：是 1图 以坐标原点顺时针旋转90°，再以 y轴 作左右对称得到的图形，观察坐标变化</p><p>1：(-1,1) -&gt; (-1,1)</p><p>2：(1,1) -&gt; (-1,-1)</p><p>3：(1,-1) -&gt; (1, -1)</p><p>4：(-1,-1) -&gt; (1,1)</p><p>即可得，变化式为</p><p>(x,y) -&gt; (y,x) -&gt;(-y,-x)</p><p>这样就可以从 1图 变成第二象限图像，再将此图像移动至 2图 的第二象限处 即（令一个方格的长度为len）</p><p>(-y + len / 2,-x - len / 2)</p><p>剩下的象限图像同理</p><p>第一象限图像：(x + len / 2, y + len / 2)</p><p>第三象限图像：(y - len / 2, x - len / 2)</p><p>第四象限图像：(x + len / 2, y - len / 2)</p><p>于是此时我们就解决了 ①</p><p>考虑 ②，我们发现 2图 的每个象限图的点上的数去减一 Mod 一图的点总数 再加一，就可以得到 2图 每个象限的个点 在 1图上的对应点。于是②解决</p><p>考虑③，对照题中给的 3图 与 2图 的图像，我们发现与 2图 和 1图 的对应关系是相同的，那么我们继续套用 1图 到 2图 的公式 进 2图 到 3图即可，毕竟我们只需要做到点的对应，一个递归解决。</p><p>那么根据上面的 ①②③，我们就可以写出代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">//前排提醒 我的递归写的较差，更简单的可以看yxc的代码</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Coordinates</span>&#123;</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x, y;<br>&#125;;<br><br>Coordinates Tem;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>Tem.x = <span class="hljs-number">0</span>;<br>Tem.y = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">Coordinates <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k)</span> </span>&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> len = (<span class="hljs-number">1ll</span> &lt;&lt; (x - <span class="hljs-number">1</span>)) * <span class="hljs-number">10</span>; <span class="hljs-comment">//每个象限的总长度</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cnt = (k - <span class="hljs-number">1</span>) / (<span class="hljs-number">1ll</span> &lt;&lt; (x * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>)); <span class="hljs-comment">//该点在第几象限</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> tnt = ((k - <span class="hljs-number">1</span>) % (<span class="hljs-number">1ll</span> &lt;&lt; (x * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>))) + <span class="hljs-number">1</span>; <span class="hljs-comment">//该点对应上一级的哪个点</span><br><br><span class="hljs-keyword">if</span>(x == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//如果到等级一了 就给坐标值</span><br><span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>) Tem.x = <span class="hljs-number">-5</span>, Tem.y = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span>(k == <span class="hljs-number">2</span>) Tem.x = <span class="hljs-number">5</span>, Tem.y = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span>(k == <span class="hljs-number">3</span>) Tem.x = <span class="hljs-number">5</span>, Tem.y = <span class="hljs-number">-5</span>;<br><span class="hljs-keyword">if</span>(k == <span class="hljs-number">4</span>) Tem.x = <span class="hljs-number">-5</span>, Tem.y = <span class="hljs-number">-5</span>;<br><span class="hljs-keyword">return</span> Tem;<br>&#125;<br><br><span class="hljs-built_in">Calculate</span>(x - <span class="hljs-number">1</span>, tnt); <span class="hljs-comment">//返回到前一级</span><br>Tem.x = Tem.x + len / <span class="hljs-number">2</span>; <span class="hljs-comment">//我这里的意思是 先统一移动到第一象限</span><br>Tem.y = Tem.y + len / <span class="hljs-number">2</span>; <span class="hljs-comment">//因为我下面的公式都是以第一象限来推的</span><br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//如果在第二象限</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x1, y1;<br>x1 = Tem.x, y1 = Tem.y;<br>Tem.x = -y1, Tem.y = -x1 + len;<br>&#125;<br><span class="hljs-comment">//第一象限我已经移动过了 所以不用写</span><br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">//如果在第四象限</span><br>Tem.y = Tem.y - len;<br>&#125;<br><br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">3</span>) &#123; <span class="hljs-comment">//如果在第三象限</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x1, y1;<br>x1 = Tem.x, y1 = Tem.y;<br>Tem.x = y1 - len, Tem.y = x1 - len;<br>&#125; <span class="hljs-keyword">return</span> Tem;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> N, a, b;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;N);<br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">while</span>(N--) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld %ld %ld&quot;</span>, &amp;n, &amp;a, &amp;b);<br>Coordinates k = <span class="hljs-built_in">Calculate</span>(n, a); <span class="hljs-built_in">init</span>(); <span class="hljs-comment">//重置一下</span><br>Coordinates m = <span class="hljs-built_in">Calculate</span>(n, b); <span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">double</span> x = k.x - m.x, y = k.y - m.y; <span class="hljs-comment">//两点距离公式</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.0lf\n&quot;</span>, <span class="hljs-built_in">sqrt</span>(x * x + y * y));<br>&#125; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>模拟</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>约数之和</title>
    <link href="/2021/10/29/%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2021/10/29/%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h1><p>假设现在有两个自然数 $A$ 和 $B$，$S$ 是 $A^B$ 的所有约数之和。</p><p>请你求出 $Smod9901$ 的值是多少。</p><p><strong>输入格式</strong></p><p>在一行中输入用空格隔开的两个整数 $A$ 和 $B$。</p><p><strong>输出格式</strong></p><p>输出一个整数，代表 $Smod9901$ 的值。</p><p><strong>数据范围</strong></p><p>$0≤A,B≤5\times 10^7$</p><p><strong>输入样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>要求 $A^B$ 的所有约数和，先求 $A$ 的所有约数和，即对 $A$ 进行质因数分解，得到式子，$A = \prod ^n_{i = 1} p_i^{c_i}$，那么可以得到 $A^B = \prod ^n_{i = 1} p_i^{c_i\times B}$，即可以得到 $A^B$ 的约数之和，为：$\prod^n_{i = 1}(1 + p^1_i + p^2_i + ..+p^{c_i\times B}_i)$如果单纯的计算每个算式，这个复杂度就会与质因数的个数和 $B$ 的乘积有关，会超时。</p><p>再观察括号内的式子满足等比数列规律，但根据等比数列的求和公式，分母分子同时会含有公比 $q$ ，分子分母不能同时 $MOD$ 后作除法，所以无论是 $S = \frac{a_1-a_nq}{1-q}$ 还是 $S = \frac {a_1(1-q^n)}{1-q}$，都可能会被数据卡掉（前者的 $a_nq$ 和 后者的 $a_1q^n$，A、B一大就会卡掉）。</p><p>一条路走不通 再返回去看式子（这里假设式子中无B），</p><p>设 $n = 5$ </p><p>就会有 $p^0 + p^1 + p^2 + p^3 + p^4 + p^5$ 总共 6 个数，我们将其拆分成相同个数的两份</p><p> $(p^0 + p^1 + p^2) + (p^3 + p^4 + p^5)$ </p><p>然后再化简 $(p^0 + p^1 + p^2) + p^3(p^0 + p^1 + p^2)$ </p><p>继续可得 $(p^0 + p^1 + p^2)\times(1 + p^3)$ ，这里是 $n$ 为奇数的情况</p><p>同理，当 $n$ 为偶数时（n = 4），可得最终式子$(p^0 + p^1) \times(1 + p^2) + p^4$</p><p>综上两种情况，再配合<a href="https://zhuanlan.zhihu.com/p/95902286">快速幂</a>这样我们就把 $O(n)$ 时间复杂度的式子变成了 $O(log^2n)$，分开情况讨论就可以得到最终的答案。</p><p>看代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">9901</span>;<br><br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>, A, B;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>a = a % MOD; <span class="hljs-comment">//注意这里要先模</span><br><span class="hljs-keyword">int</span> val = <span class="hljs-number">1</span> % MOD;<br><span class="hljs-keyword">while</span>(b) &#123;<br><span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>) val = val * a % MOD;<br>b = b &gt;&gt; <span class="hljs-number">1</span>;<br>a = a * a % MOD;<br>&#125; <span class="hljs-keyword">return</span> val;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(n, k &gt;&gt; <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> + <span class="hljs-built_in">qmi</span>(n, (k &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>)) % MOD;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(n, (k &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> + <span class="hljs-built_in">qmi</span>(n, k &gt;&gt; <span class="hljs-number">1</span>)) % MOD + <span class="hljs-built_in">qmi</span>(n, k) % MOD;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;A, &amp;B);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= A; i++) &#123;<br><span class="hljs-keyword">int</span> tot = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(!(A % i)) &#123;<br>tot++;<br>A /= i;<br>&#125; <br><br><span class="hljs-keyword">if</span>(tot) ans = ans * <span class="hljs-built_in">sum</span>(i, tot * B) % MOD;<br>&#125; <br><br><span class="hljs-keyword">if</span>(A == <span class="hljs-number">0</span>) ans = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数学</tag>
      
      <tag>快速幂</tag>
      
      <tag>分治</tag>
      
      <tag>分解质因数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>奇怪的汉诺塔</title>
    <link href="/2021/10/29/%E5%A5%87%E6%80%AA%E7%9A%84%E6%B1%89%E8%AF%BA%E5%A1%94/"/>
    <url>/2021/10/29/%E5%A5%87%E6%80%AA%E7%9A%84%E6%B1%89%E8%AF%BA%E5%A1%94/</url>
    
    <content type="html"><![CDATA[<h1 id="奇怪的汉诺塔"><a href="#奇怪的汉诺塔" class="headerlink" title="奇怪的汉诺塔"></a>奇怪的汉诺塔</h1><p>汉诺塔问题，条件如下：</p><p>1、这里有 $A、B、C$ 和 $D$ 四座塔。</p><p>2、这里有 $n$ 个圆盘，$n$ 的数量是恒定的。</p><p>3、每个圆盘的尺寸都不相同。</p><p>4、所有的圆盘在开始时都堆叠在塔 $A$ 上，且圆盘尺寸从塔顶到塔底逐渐增大。</p><p>5、我们需要将所有的圆盘都从塔 $A$ 转移到塔 $D$ 上。</p><p>6、每次可以移动一个圆盘，当塔为空塔或者塔顶圆盘尺寸大于被移动圆盘时，可将圆盘移至这座塔上。</p><p>请你求出将所有圆盘从塔 $A$ 移动到塔 $D$，所需的最小移动次数是多少。</p><p><img src="https://www.acwing.com/media/article/image/2019/01/10/19_acbb764014-%E6%B2%B3%E5%86%85%E5%A1%94.jpg"></p><p>（三柱汉诺塔参考模型，注意 题中是四根柱子）</p><p><strong>输入格式</strong></p><p>没有输入</p><p><strong>输出格式</strong></p><p>对于每一个整数 nn，输出一个满足条件的最小移动次数，每个结果占一行。</p><p><strong>数据范围</strong></p><p>$1≤n≤12$</p><p><strong>输入样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">没有输入<br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">参考输出样例<br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>汉诺塔经典问题，先推三塔公式 $d_i = d_{i - 1} \times 2 + 1$</p><p>假设只有三个盘子，最优的解法是先将最大的盘子放到第三根柱子上，然后剩下两个盘子再放到第三根柱子上，那么这样就变成了 <strong>两个盘子的问题</strong>，因为最大的盘子丝毫不影响剩下的盘子移动。即我们先将前两个盘子以两个盘子的最优步数放到第二根柱子上，然后将第三个盘子放到第三根柱子上，再将第二根柱子上的两个盘子以两个盘子的最优步数放到第三根柱子上，这样就达成了三根柱子三个盘子的最优步数，同理 $n$ 个盘子也是如此，所以得到公式 $d_i = d_{i - 1} \times 2 + 1$</p><p>推完三塔公式，就来推四塔公式，四塔唯一和三塔不同的是，假设有 $k$ 个盘子，第 $d$ （$0 ≤ d ＜ k)$ 个盘子（包括 $d$）以下的盘子是以三塔的方式移动，而第 $d$ 个盘子以上的盘子却是以四塔的方式移动，而四塔方式的最优步数却是由一共有 $d - 1$ 个盘子的最优步数推来的，那么代码就很好写了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">a[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">12</span>; i++) &#123;<br>    a[i] = a[i - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>&#125;<br>    <br><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));<br>f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">12</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>        f[i] = std::<span class="hljs-built_in">min</span>(f[i], <span class="hljs-number">2</span> * f[j] + a[i - j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下是总代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">15</span>;<br><span class="hljs-keyword">int</span> a[N], f[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    a[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">12</span>; i++) &#123;<br>        a[i] = a[i - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));<br>    f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">12</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>            f[i] = std::<span class="hljs-built_in">min</span>(f[i], <span class="hljs-number">2</span> * f[j] + a[i - j]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">12</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[i]);<br>    &#125; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>模拟</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>费解的开关</title>
    <link href="/2021/10/28/%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/"/>
    <url>/2021/10/28/%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="费解的开关"><a href="#费解的开关" class="headerlink" title="费解的开关"></a>费解的开关</h1><p>你玩过“拉灯”游戏吗？</p><p>$25$ 盏灯排成一个 $5×5$ 的方形。</p><p>每一个灯都有一个开关，游戏者可以改变它的状态。</p><p>每一步，游戏者可以改变某一个灯的状态。</p><p>游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。</p><p>我们用数字 $1$ 表示一盏开着的灯，用数字 $0$ 表示关着的灯。</p><p>下面这种状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">10111</span><br><span class="hljs-number">01101</span><br><span class="hljs-number">10111</span><br><span class="hljs-number">10000</span><br><span class="hljs-number">11011</span><br></code></pre></td></tr></table></figure><p>在改变了最左上角的灯的状态后将变成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">01111</span><br><span class="hljs-number">11101</span><br><span class="hljs-number">10111</span><br><span class="hljs-number">10000</span><br><span class="hljs-number">11011</span><br></code></pre></td></tr></table></figure><p>再改变它正中间的灯后状态将变成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">01111</span><br><span class="hljs-number">11001</span><br><span class="hljs-number">11001</span><br><span class="hljs-number">10100</span><br><span class="hljs-number">11011</span><br></code></pre></td></tr></table></figure><p>给定一些游戏的初始状态，编写程序判断游戏者是否可能在 $6$ 步以内使所有的灯都变亮。</p><p><strong>输入格式</strong></p><p>第一行输入正整数 $n$，代表数据中共有 $n$ 个待解决的游戏初始状态。</p><p>以下若干行数据分为 $n$ 组，每组数据有 $5$ 行，每行 $5$ 个字符。</p><p>每组数据描述了一个游戏的初始状态。</p><p>各组数据间用一个空行分隔。</p><p><strong>输出格式</strong></p><p>一共输出 $n$ 行数据，每行有一个小于等于 $6$ 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。</p><p>对于某一个游戏初始状态，若 $6$ 步以内无法使所有灯变亮，则输出 $−1$。</p><p><strong>数据范围</strong></p><p>$0&lt;n≤500$</p><p><strong>输入样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">3</span><br><span class="hljs-number">00111</span><br><span class="hljs-number">01011</span><br><span class="hljs-number">10001</span><br><span class="hljs-number">11010</span><br><span class="hljs-number">11100</span><br><br><span class="hljs-number">11101</span><br><span class="hljs-number">11101</span><br><span class="hljs-number">11110</span><br><span class="hljs-number">11111</span><br><span class="hljs-number">11111</span><br><br><span class="hljs-number">01111</span><br><span class="hljs-number">11111</span><br><span class="hljs-number">11111</span><br><span class="hljs-number">11111</span><br><span class="hljs-number">11111</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>① 读完，对于一个开关，只有开或关两种状态可选，而且我们要的是最少的操作数，那么就说明 <strong>一个开关不会按第二下</strong>，因为按第二下就是撤销上一次的操作 那不如上一次就不按。</p><p>② 在操作确定的情况下，任意两个开关的按下顺序是可以互换的，证明：将所有的开关上标上该开关被影响的次数，我们发现无论开关的顺序如何 开关上的影响次数都是一样的。</p><p>③ 一个开关的状态改变会影响周围四个开关的状态，简化问题，如果开关只会影响上下的状态（左右的话将图横过来即同理），那么当前第 $k$ 排的最优解就是将第 $k-1$ 排的未打开的开关打开，因为第 $k + 1$ 排的开关会由 $k$ 排、$k +1$ 排、$k + 2$ 排所影响，而 $k-1$ 排此时却只能由 $k$ 排来影响自身的状态，同理，增加一个左右并不会改变这个决策的正确性，且这样做只会有唯一确定的操作（多种按法请看 ②）</p><p>但同样产生一个问题，起始排的状态应该如何确定？因为我们的决策是从第二排开始确定，而第一排的状态却无法确定，也许第一排的某一个或几个位置的状态改变会导致结果变得更优。观察数据，一排只有五个数，那就直接用 <strong>二进制枚举</strong>，$2^5$ 种情况全部枚举即可。</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">505</span>;<br>std::string c[N][<span class="hljs-number">6</span>];<br><span class="hljs-keyword">int</span> a[N][<span class="hljs-number">6</span>][<span class="hljs-number">6</span>], m[N][<span class="hljs-number">6</span>][<span class="hljs-number">6</span>];<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">effect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n1, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(m[n1][x][y] == <span class="hljs-number">1</span>) m[n1][x][y] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> m[n1][x][y] = <span class="hljs-number">1</span>;  <br><span class="hljs-keyword">if</span>(m[n1][x + <span class="hljs-number">1</span>][y] == <span class="hljs-number">1</span>) m[n1][x + <span class="hljs-number">1</span>][y] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> m[n1][x + <span class="hljs-number">1</span>][y] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(m[n1][x - <span class="hljs-number">1</span>][y] == <span class="hljs-number">1</span>) m[n1][x - <span class="hljs-number">1</span>][y] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> m[n1][x - <span class="hljs-number">1</span>][y] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(m[n1][x][y + <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) m[n1][x][y + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> m[n1][x][y + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(m[n1][x][y - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) m[n1][x][y - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> m[n1][x][y - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">5</span>; j++) &#123;<br>std::cin &gt;&gt; c[i][j];<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">5</span>; j++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">5</span>; k++) &#123;<br>a[i][j][k + <span class="hljs-number">1</span>] = c[i][j][k] - <span class="hljs-number">48</span>;<br>m[i][j][k + <span class="hljs-number">1</span>] = c[i][j][k] - <span class="hljs-number">48</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> tot = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0x3f</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> f = <span class="hljs-number">0</span>; f &lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>; f++) &#123;<br>tot = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br><span class="hljs-keyword">if</span>(f &gt;&gt; j &amp; <span class="hljs-number">1</span>) &#123;<br>tot++;<br><span class="hljs-built_in">effect</span>(k, <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">5</span>; j++) &#123;<br><span class="hljs-keyword">if</span>(m[k][i - <span class="hljs-number">1</span>][j] == <span class="hljs-number">0</span>) &#123;<br>tot++;<br><span class="hljs-built_in">effect</span>(k, i, j);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br><span class="hljs-keyword">if</span>(m[k][<span class="hljs-number">5</span>][i] == <span class="hljs-number">0</span>) tot = <span class="hljs-number">0x3f</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">5</span>; j++) &#123;<br>m[k][i][j] = a[k][i][j];<br>&#125;<br>&#125;<br><br>ans = std::<span class="hljs-built_in">min</span>(ans, tot);<br>&#125;<br><br><span class="hljs-keyword">if</span>(ans &gt; <span class="hljs-number">6</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>&#125; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>位运算</tag>
      
      <tag>模拟</tag>
      
      <tag>递推</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归实现排列型枚举</title>
    <link href="/2021/10/28/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E5%9E%8B%E6%9E%9A%E4%B8%BE/"/>
    <url>/2021/10/28/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E5%9E%8B%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="递归实现组合型枚举"><a href="#递归实现组合型枚举" class="headerlink" title="递归实现组合型枚举"></a>递归实现组合型枚举</h1><p>把 $1∼n$ 这 $n$ 个整数排成一行后随机打乱顺序，输出所有可能的次序。</p><p><strong>输入格式</strong></p><p>一个整数 $n$</p><p><strong>输出格式</strong></p><p>按照从小到大的顺序输出所有方案，每行 $1$ 个。</p><p>首先，同一行相邻两个数用一个空格隔开。</p><p>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。</p><p><strong>数据范围</strong></p><p>$1 ≤ n ≤ 9$</p><p><strong>输入样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>全排列题，没参考性 直接水</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        arr[i] = i;<br>    &#125;<br>    <br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);<br>        &#125; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125; <span class="hljs-keyword">while</span>(std::<span class="hljs-built_in">next_permutation</span>(arr + <span class="hljs-number">1</span>, arr + <span class="hljs-number">1</span> + n));<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>全排列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归实现组合型枚举</title>
    <link href="/2021/10/28/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE/"/>
    <url>/2021/10/28/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="递归实现组合型枚举"><a href="#递归实现组合型枚举" class="headerlink" title="递归实现组合型枚举"></a>递归实现组合型枚举</h1><p>从 $1∼n$ 这 $n$ 个整数中随机选取 $m$ 个，输出所有可能的选择方案。</p><p><strong>输入格式</strong></p><p>两个整数 $n, m$</p><p><strong>输出格式</strong></p><p>按照从小到大的顺序输出所有方案，每行 $1$ 个。</p><p>首先，同一行内的数升序排列，相邻两个数用一个空格隔开。</p><p>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 <code>1 3 5 7</code> 排在 <code>1 3 6 8</code> 前面）。</p><p><strong>数据范围</strong></p><p>$n&gt;0$<br>$0≤m≤n$<br>$n+(n−m)≤25$</p><p><strong>输入样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">5</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <br><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <br><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <br></code></pre></td></tr></table></figure><p><strong>思考题</strong>：如果要求使用非递归方法，该怎么做呢？</p><p><strong>解析</strong></p><p><a href="https://lovehshan.top/2021/10/27/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8C%87%E6%95%B0%E5%9E%8B%E6%9E%9A%E4%B8%BE/">上一道题</a>的另外一个版本，用 dfs 同理，这次存进 $m$ 个就跳出循环即可，本题的另一个问题是使用非递归的方法。</p><p>正好把我们的位运算继续拿出来继续用， $m$ 个数的条件好说，但是这次需要根据字典序排序，再用上次的方法就不行了（这里思考为什么不行？提供代码）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i++) &#123;<br><span class="hljs-keyword">int</span> tot = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br><span class="hljs-keyword">if</span>(i &gt;&gt; j &amp; <span class="hljs-number">1</span>) tot++;<br>&#125; <span class="hljs-keyword">if</span>(tot == m) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span>(i &gt;&gt; j &amp; <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, j + <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);   <br>&#125;<br>&#125; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然要排序，那我们用结构体储存了之后再用 sort 的排序即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">int</span> n, m, tot, tnt;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100005</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> &#123;</span><br>    std::vector&lt;<span class="hljs-keyword">int</span>&gt; v1;<br>&#125; arr[N];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(point a, point b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> equal = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(a.v1[equal] == b.v1[equal]) equal++;<br>    <span class="hljs-keyword">return</span> a.v1[equal] &lt; b.v1[equal];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i++) &#123;<br>    <span class="hljs-keyword">int</span> tot = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br><span class="hljs-keyword">if</span>(i &gt;&gt; j &amp; <span class="hljs-number">1</span>) tot++;<br>&#125; <span class="hljs-keyword">if</span>(tot == m) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span>(i &gt;&gt; j &amp; <span class="hljs-number">1</span>) arr[tnt].v1.<span class="hljs-built_in">push_back</span>(j + <span class="hljs-number">1</span>);<br>    &#125; tnt++;<br>&#125;<br>&#125;<br><br>std::<span class="hljs-built_in">sort</span>(arr, arr + tnt, cmp);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tnt; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i].v1[j]);<br>    &#125; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处在书前还有一个 $lowbit$ 的详细用法，我们再使用 $lowbit$ 解决这道题</p><p>$lowbit$ 的定义是<strong>非负整数 n 在二进制表示下 “最低位的 1 及其后边所有的 0”构成的数值</strong>，所以我们插入使用一下即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">int</span> n, m, tot, tnt;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100005</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> &#123;</span><br>    std::vector&lt;<span class="hljs-keyword">int</span>&gt; v1;<br>&#125; arr[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">return</span> x &amp; (-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(point a, point b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> equal = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(a.v1[equal] == b.v1[equal]) equal++;<br>    <span class="hljs-keyword">return</span> a.v1[equal] &lt; b.v1[equal];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i++) &#123;<br>    <span class="hljs-keyword">int</span> tot = <span class="hljs-number">0</span>, val = i;<br><span class="hljs-keyword">while</span>(val) &#123; val -= <span class="hljs-built_in">lowbit</span>(val); tot++; &#125; <span class="hljs-comment">// &lt;- 这里</span><br><span class="hljs-keyword">if</span>(tot == m) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span>(i &gt;&gt; j &amp; <span class="hljs-number">1</span>) arr[tnt].v1.<span class="hljs-built_in">push_back</span>(j + <span class="hljs-number">1</span>);<br>    &#125; tnt++;<br>&#125;<br>&#125;<br><br>std::<span class="hljs-built_in">sort</span>(arr, arr + tnt, cmp);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tnt; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i].v1[j]);<br>    &#125; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>位运算</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归实现指数型枚举</title>
    <link href="/2021/10/27/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8C%87%E6%95%B0%E5%9E%8B%E6%9E%9A%E4%B8%BE/"/>
    <url>/2021/10/27/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8C%87%E6%95%B0%E5%9E%8B%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="递归实现指数型枚举"><a href="#递归实现指数型枚举" class="headerlink" title="递归实现指数型枚举"></a>递归实现指数型枚举</h1><p>从 $1∼n$ 这 $n$ 个整数中随机选取任意多个，输出所有可能的选择方案。</p><p><strong>输入格式</strong></p><p>输入一个整数 $n$</p><p><strong>输出格式</strong></p><p>每行输出一种方案。</p><p>同一行内的数必须升序排列，相邻两个数用恰好 $1$ 个空格隔开。</p><p>对于没有选任何数的方案，输出空行。</p><p>本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。</p><p><strong>数据范围</strong></p><p>$1\leqslant n\leqslant 15 $</p><p><strong>输入样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>两种方法，状态压缩和正常的递归dfs</p><p>首先讲第一种，对前面<a href="https://lovehshan.top/2021/10/26/%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84/">最短Hamilton路径</a>理解了的，就很好想</p><p>因为 $1≤n≤15$ ，所以可以枚举所有的情况，总共只有 $2^{15}$ 种情况，即只有 $32768$ 种情况</p><p>然后输出第 $k$ 位为 $1$ 的 $k$ 即可。</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br><span class="hljs-keyword">if</span>(i &gt;&gt; j &amp; <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, j + <span class="hljs-number">1</span>);<br>&#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是第二种，简单的遍历所有拿还是不拿的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">int</span> a[N];<br><br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(k == n + <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span>(a[i] == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);<br>&#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>    <br><span class="hljs-built_in">dfs</span>(k + <span class="hljs-number">1</span>);<br>a[k] = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs</span>(k + <span class="hljs-number">1</span>);<br>a[k] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>位运算</tag>
      
      <tag>递归</tag>
      
      <tag>状态压缩</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>起床困难综合症</title>
    <link href="/2021/10/27/%E8%B5%B7%E5%BA%8A%E5%9B%B0%E9%9A%BE%E7%BB%BC%E5%90%88%E7%97%87/"/>
    <url>/2021/10/27/%E8%B5%B7%E5%BA%8A%E5%9B%B0%E9%9A%BE%E7%BB%BC%E5%90%88%E7%97%87/</url>
    
    <content type="html"><![CDATA[<h1 id="起床困难综合症"><a href="#起床困难综合症" class="headerlink" title="起床困难综合症"></a>起床困难综合症</h1><p>$21$ 世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。</p><p>作为一名青春阳光好少年，atm 一直坚持与起床困难综合症作斗争。</p><p>通过研究相关文献，他找到了该病的发病原因： 在深邃的太平洋海底中，出现了一条名为 drd 的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。</p><p>正是由于 drd 的活动，起床困难综合症愈演愈烈， 以惊人的速度在世界上传播。</p><p>为了彻底消灭这种病，atm 决定前往海底，消灭这条恶龙。</p><p>历经千辛万苦，atm 终于来到了 drd 所在的地方，准备与其展开艰苦卓绝的战斗。</p><p>drd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。</p><p>具体说来，drd 的防御战线由 $n$ 扇防御门组成。</p><p>每扇防御门包括一个运算 $op$ 和一个参数 $t$，其中运算一定是 $OR,XOR,AND$ 中的一种，参数则一定为非负整数。</p><p>如果还未通过防御门时攻击力为 $x$，则其通过这扇防御门后攻击力将变为 $x op t$。</p><p>最终 drd 受到的伤害为对方初始攻击力 $x$ 依次经过所有 $n$ 扇防御门后转变得到的攻击力。</p><p>由于 atm 水平有限，他的初始攻击力只能为 $0$ 到 $m$ 之间的一个整数（即他的初始攻击力只能在 $0,1,…,m$ 中任选，但在通过防御门之后的攻击力不受 $m$ 的限制）。</p><p>为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 drd 受到多少伤害。</p><p><strong>输入格式</strong></p><p>第 $1$ 行包含 $2$ 个整数，依次为 $n,m$，表示 drd 有 $n$ 扇防御门，atm 的初始攻击力为 $0$ 到 $m$ 之间的整数。</p><p>接下来 $n$ 行，依次表示每一扇防御门。每行包括一个字符串 $op$ 和一个非负整数 $t$，两者由一个空格隔开，且 $op$ 在前，$t$ 在后，$op$ 表示该防御门所对应的操作，$t$ 表示对应的参数。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示 atm 的一次攻击最多使 drd 受到多少伤害。</p><p><strong>数据范围</strong></p><p><img src="https://cdn.acwing.com/media/article/image/2019/09/07/19_9f80784cd1-QQ%E6%88%AA%E5%9B%BE20190907125839.png"></p><p><strong>输入样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">3</span> <span class="hljs-number">10</span><br>AND <span class="hljs-number">5</span><br>OR <span class="hljs-number">6</span><br>XOR <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>样例解释</strong></p><p>atm可以选择的初始攻击力为 $0,1,…,10$。</p><p>假设初始攻击力为 $4$，最终攻击力经过了如下计算</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-keyword">AND</span> <span class="hljs-number">5</span> = <span class="hljs-number">4</span><br><br><span class="hljs-symbol">4 </span><span class="hljs-keyword">OR</span> <span class="hljs-number">6</span> = <span class="hljs-number">6</span><br><br><span class="hljs-symbol">6 </span><span class="hljs-keyword">XOR</span> <span class="hljs-number">7</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>类似的，我们可以计算出初始攻击力为 $1,3,5,7,9$ 时最终攻击力为 $0$，初始攻击力为 $0,2,4,6,8,10$ 时最终攻击力为 $1$，因此 atm 的一次攻击最多使 drd 受到的伤害值为 $1$。</p><p><strong>运算解释</strong></p><p>在本题中，选手需要先将数字变换为二进制后再进行计算。如果操作的两个数二进制长度不同，则在前补 $0$ 至相同长度。</p><ul><li>OR 为按位或运算，处理两个长度相同的二进制数，两个相应的二进制位中只要有一个为 $1$，则该位的结果值为 $1$，否则为 $0$。</li><li>XOR 为按位异或运算，对等长二进制模式或二进制数的每一位执行逻辑异或操作。如果两个相应的二进制位不同（相异），则该位的结果值为 $1$，否则该位为 $0$。</li><li>AND 为按位与运算，处理两个长度相同的二进制数，两个相应的二进制位都为 $1$，该位的结果值才为 $1$，否则为 $0$。</li></ul><p>例如，我们将十进制数 $5$ 与十进制数 $3$ 分别进行 $OR、XOR$ 与 $AND$ 运算，可以得到如下结果：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lisp">   <span class="hljs-number">0101</span> (十进制 <span class="hljs-number">5</span>)             <span class="hljs-number">0101</span> (十进制 <span class="hljs-number">5</span>)             <span class="hljs-number">0101</span> (十进制 <span class="hljs-number">5</span>)             <br>OR <span class="hljs-number">0011</span> (十进制 <span class="hljs-number">3</span>)         XOR <span class="hljs-number">0011</span> (十进制 <span class="hljs-number">3</span>)         AND <span class="hljs-number">0011</span> (十进制 <span class="hljs-number">3</span>)             <br> = <span class="hljs-number">0111</span> (十进制 <span class="hljs-number">7</span>)           = <span class="hljs-number">0110</span> (十进制 <span class="hljs-number">6</span>)           = <span class="hljs-number">0001</span> (十进制 <span class="hljs-number">1</span>)          <br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>字有点多，本质是一道模拟题和单纯考位运算的熟练程度。</p><p>先观察取值范围，$t$ 的最大值为1e9，即二进制后位数不会超过30位，而对于未知数 $x$ 而言，二进制下的第 $k$ 位只会有 $0$ 或 $1$ 两种值，我们直接带进去枚举就可以了。</p><p>$989898$ 与 $889898$，根据常识我们知道肯定是 $989898 &gt; 889898$，这里同理，我们从最高位开始枚举得到的结果就是最优解；再根据题意可得一个条件，得到的未知数 $x$ 的范围在 $[0, m]$，所以我们每次只需要判断当前填 $1$ 得到的最优 $x$ 值是否 &gt; m 即可，如果大于则当前位置上一定是填 $0$。</p><p>剩下的就是比较填 $1$ 能打的伤害最大还是填 $0$ 能打的伤害最大，这个就是比谁能在样例给的数据的计算结果中得到 $1$ 了。</p><p>时间复杂度为 $O(30\times n\times 2 \times log_2^m)$ 即为 $O(nlogm)$</p><p>放代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> t[N];<br>std::string op[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">char</span> str[<span class="hljs-number">5</span>]; <span class="hljs-keyword">int</span> x;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s %d&quot;</span>, str, &amp;x);<br>op[i] = str;<br>t[i] = x;<br>&#125;<br><br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-keyword">int</span> res1 = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br><span class="hljs-keyword">int</span> f = t[j] &gt;&gt; i &amp; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(op[j] == <span class="hljs-string">&quot;OR&quot;</span>) res1 |= f;<br><span class="hljs-keyword">if</span>(op[j] == <span class="hljs-string">&quot;AND&quot;</span>) res1 &amp;= f;<br><span class="hljs-keyword">if</span>(op[j] == <span class="hljs-string">&quot;XOR&quot;</span>) res1 ^= f;<br>&#125;<br><br><span class="hljs-keyword">int</span> res0 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br><span class="hljs-keyword">int</span> f = t[j] &gt;&gt; i &amp; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(op[j] == <span class="hljs-string">&quot;OR&quot;</span>) res0 |= f;<br><span class="hljs-keyword">if</span>(op[j] == <span class="hljs-string">&quot;AND&quot;</span>) res0 &amp;= f;<br><span class="hljs-keyword">if</span>(op[j] == <span class="hljs-string">&quot;XOR&quot;</span>) res0 ^= f;<br>&#125;<br><br><span class="hljs-keyword">if</span>((res1 &gt; res0) &amp;&amp; (x + (<span class="hljs-number">1</span> &lt;&lt; i)) &lt;= m) &#123;<br>x += <span class="hljs-number">1</span> &lt;&lt; i; ans += res1 &lt;&lt; i;<br>&#125; <span class="hljs-keyword">else</span> ans += res0 &lt;&lt; i;<br>&#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>位运算</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短Hamilton路径</title>
    <link href="/2021/10/26/%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84/"/>
    <url>/2021/10/26/%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a>最短Hamilton路径</h1><p>给定一张 $n$ 个点的带权无向图，点从 $0∼n−1$ 标号，求起点 $0$ 到终点 $n−1$ 的最短 $Hamilton$ 路径。</p><p>$Hamilton$ 路径的定义是从 $0$ 到 $n−1$ 不重不漏地经过每个点恰好一次。</p><p><strong>输入格式</strong></p><p>第一行输入整数 $n$。</p><p>接下来 $n$ 行每行 $n$ 个整数，其中第 $i$ 行第 $j$ 个整数表示点 $i$ 到 $j$ 的距离（记为 $a[i,j]$）。</p><p>对于任意的 $x,y,z$，数据保证 $a[x,x]=0，a[x,y]=a[y,x]$ 并且 $a[x,y]+a[y,z]≥a[x,z]$。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最短 $Hamilton$ 路径的长度。</p><p><strong>数据范围</strong></p><p>$1\leqslant n\leqslant 20 $</p><p>$0\leqslant a[i,j]\leqslant 10^{7}$</p><p><strong>输入样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">5</span><br><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><br><span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">8</span> <span class="hljs-number">3</span><br><span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>考虑简单的做法，将 $n$ 个数塞入 $k_n$ 的数组中，对 $k_n$ 进行全排列，将每次全排列的结果根据输入的 $a_{i,j}$ 得出Hamilton路径的长度，每次的得数取 $min$ 即为最终答案。</p><p>时间复杂度为 $O(n\times n!)$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ans = <span class="hljs-number">0x3f</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(k, k+n)) &#123;<br>    res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        res += a[k[i - <span class="hljs-number">1</span>]][k[j]];<br>    &#125; ans = std::<span class="hljs-built_in">min</span>(ans, res);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（注意各处未知数的含义！！！相同的 $i$ 和 $i$ 可能表示不同的意思）</strong></p><p>考虑简化问题，设 $f_{i,j}$ 为当前所记录的 i-&gt;j 的最短距离，此时存在另外一条路线 i-&gt;k-&gt;j 的距离是小于 $f_{i,j}$ ，那么此时将 $f_{i,j}$ 的距离更新为 i-&gt;k-&gt;j 的距离即可。</p><p>那么就会存在两个问题</p><p>1、如何知道 $k$ 是否是没走过的点</p><p>2、如何记录 $f_{i,j}$ 是由 i-&gt;k-&gt;j</p><p>我们发现，上面的问题中，$i$ 是一直没有动过的，我们改变的一直是我们当前所在的点，即 $k、j$，那么我们就可以将 $i$ 变成记录当前所有点的状态，而后面的 $j$ 变成记录当前的所处点，那如何用 $i$ 记录当前所有点的状态呢？用二进制数表示。</p><p>我们发现 $n$ 很小，只有20，$f_{1&lt;&lt;20,20}$ 的最大值是 20971520，并不会爆空间，我们用 0 和 1 和当前数字所处的位置来表示第几个点是否走过。</p><p>这样我们就解决了第一个问题，然后来解决第二个问题。</p><p>假设 i-&gt;k-&gt;j 一定是最优的最短距离，且在状态 $i$ 中，$i,j,k$ 点均走过了（即在 $i,j,k$ 位上的数都是1），那么 $f_{i,j}$ 的距离一定是 i-&gt;k-&gt;j。</p><p>但是注意，以上的解法泛用所有的情况，假设我们有五个点 $i,j,k,x,y$，此时i-&gt;k-&gt;j-&gt;x-&gt;y 的距离大于 i-&gt;j-&gt;x-&gt;k-&gt;y，那我们就要选第二种为最短距离，此时和第一种解法是一样的，将其看做 $f_{i,y}$ ，而中间的数看成 $k$，而中间又可以…（这里同理），所以我们只需要枚举 $i$ 的所有情况即可。</p><p>那么时间复杂度就是 $O((1&lt;&lt;n) \times n\times n)$ 即为 $O(2^n\times n^2)$</p><p>其他看代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">int</span> f[<span class="hljs-number">1</span> &lt;&lt; N][N];<br><span class="hljs-keyword">int</span> a[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i][j]);<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f)); <span class="hljs-comment">//得到最小值 所以起始值为最大值</span><br>f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//自己走自己是0  1的二进制就是1</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i++) &#123; <span class="hljs-comment">//枚举所有的情况</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) <span class="hljs-keyword">if</span>(i &gt;&gt; j &amp; <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">//第 j 位是否走过</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k++) <span class="hljs-keyword">if</span>((i ^ <span class="hljs-number">1</span> &lt;&lt; j) &gt;&gt; k &amp; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//第 k 位是否走过，(i ^ 1 &lt;&lt; j)的意思是 这里排除了 k == j 的情况 （自行理解）</span><br>f[i][j] = std::<span class="hljs-built_in">min</span>(f[i][j], f[i ^ <span class="hljs-number">1</span> &lt;&lt; j][k] + a[k][j]); <span class="hljs-comment">//f[i][j] 的状态是由 f[i][k] -&gt; f[k][j]得来 而 j 是后走的 所以在前面的 i 中的 j 是没走的状态 要先去掉</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, f[(<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>位运算</tag>
      
      <tag>动态规划</tag>
      
      <tag>状压dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>64位整数乘法</title>
    <link href="/2021/10/26/64%E4%BD%8D%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95/"/>
    <url>/2021/10/26/64%E4%BD%8D%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="64位整数乘法"><a href="#64位整数乘法" class="headerlink" title="64位整数乘法"></a>64位整数乘法</h1><p>求 $a$ 乘 $b$ 对 $p$ 取模的值。</p><p><strong>输入格式</strong></p><p>三个整数 $a,b,p$</p><p><strong>输出格式</strong></p><p>输出一个整数，表示 <em>a×b mod p</em> 的值</p><p><strong>数据范围</strong></p><p>$0\leqslant a,b\leqslant 10^{18} $</p><p>$1\leqslant p\leqslant 10^{18}$</p><p><strong>输入样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>（默认懂位运算，不懂的查）</p><p>和<a href="https://lovehshan.top/2021/10/25/a%E7%9A%84b%E6%AC%A1%E6%96%B9/">上一道题</a>一样，不过这次不是超时，而是爆longlong。</p><p>同理，用数学常识将 $b$ 分解，不再多解释 放代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a, b, p;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld %lld&quot;</span>, &amp;a, &amp;b, &amp;p);<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(; b; b &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>) ans = (ans + a) % p;<br>a = a * <span class="hljs-number">2</span> % p;<br>&#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>a的b次方</title>
    <link href="/2021/10/25/a%E7%9A%84b%E6%AC%A1%E6%96%B9/"/>
    <url>/2021/10/25/a%E7%9A%84b%E6%AC%A1%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="a-b-p"><a href="#a-b-p" class="headerlink" title="a^b%p"></a>a^b%p</h1><p>求 $a$ 的 $b$ 次方对 $p$ 取模的值。</p><p><strong>输入格式</strong></p><p>三个整数 $a,b,p$</p><p><strong>输出格式</strong></p><p>输出一个整数，表示 <em>a^b mod p</em> 的值</p><p><strong>数据范围</strong></p><p>$0\leqslant a,b\leqslant 10^9 $</p><p>$1\leqslant p\leqslant 10^9$</p><p><strong>输入样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><p>（默认懂位运算，不懂的查）</p><p>要求 $a^b \mod p$ 就要先解决 $a^b$ ，因为根据模的运算定理 $(a*b)\mod p = (a\mod p \times b\mod p)\mod p$ 而 $a^b = a\times a\times a …\times a$ </p><p>若 $a = b = 10^9$ 那么 $a^b$ 就会超时</p><p>考虑简化 $b$，由数学常识可得<strong>一个正整数可以唯一表示为若干指数不重复的2的次幂的和</strong>，即$b = c_{k - 1}\times{2^{k - 1}} + c_{k - 2}\times{2^{k - 2}} + …+c_{0}\times{2^0}$ ，$c$ 的值为 $b$ 的二进制在 $k$ 位置上的值</p><p>那么这样就易得 $a^b = a^{c_{k - 1}\times{2^{k - 1}}} \times a^{c_{k - 2}\times{2^{k - 2}}} \times … \times a^{c_{0}\times {2^{0}}}$ 而 $c_k\times{2^k}$ 的最大值不会超过 $log_2^{1e9 + 1}$ 即不会超过 $30$ ，这样就将时间复杂度从 $O(b)$ 变为了 $O(log_2^b)$ </p><p>计算的时候还需要观察一下规律，假设我们最后得到的是这样一个式子 $a^{1\times1} \times a^{0\times2} \times a^{1\times4} \times a^{1 \times 8}$ 我们发现， 无论 $c$ 的值为何值，从第二项开始后面的值 $2^k$ 都是上一次的值 $(2^{k-1})^2$，而且之前的值我们是不会再次调用的，于是就可以用 $a$ 的值继承就好。 </p><p>综上，可得计算代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span> % p <span class="hljs-comment">//一定要 %p 因为可能 b = 0, p = 1</span><br><span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>) ans = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)ans * a % p;<br>a = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)a * a % p;<br>&#125; <br></code></pre></td></tr></table></figure><p>最后放过题代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> a, b, p;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;p);<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span> % p;<br><span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>) ans = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)ans * a % p;<br>a = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)a * a % p;<br>&#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>必修一举折法和正身木构架作业笔记反馈</title>
    <link href="/2021/10/25/%E5%BF%85%E4%BF%AE%E4%B8%80%E4%B8%BE%E6%8A%98%E6%B3%95%E5%92%8C%E6%AD%A3%E8%BA%AB%E6%9C%A8%E6%9E%84%E6%9E%B6%E4%BD%9C%E4%B8%9A%E7%AC%94%E8%AE%B0%E5%8F%8D%E9%A6%88/"/>
    <url>/2021/10/25/%E5%BF%85%E4%BF%AE%E4%B8%80%E4%B8%BE%E6%8A%98%E6%B3%95%E5%92%8C%E6%AD%A3%E8%BA%AB%E6%9C%A8%E6%9E%84%E6%9E%B6%E4%BD%9C%E4%B8%9A%E7%AC%94%E8%AE%B0%E5%8F%8D%E9%A6%88/</url>
    
    <content type="html"><![CDATA[<h1 id="必修一举折法和正身木构架作业笔记反馈"><a href="#必修一举折法和正身木构架作业笔记反馈" class="headerlink" title="必修一举折法和正身木构架作业笔记反馈"></a>必修一举折法和正身木构架作业笔记反馈</h1><blockquote><p>课件使用 @2020明城京联合太学 必修一·唐宋梁架基础 举折法和正身木构架</p></blockquote><h2 id="正身木构架"><a href="#正身木构架" class="headerlink" title="正身木构架"></a>正身木构架</h2><p>古建筑屋顶的横截面大都是“介”字型</p><p>大部分的古建筑屋顶是很多这样的 介 字形的梁架并排拼接而成的。而每一个这样的结构都需要支撑前后两坡屋顶。这就是『正身木构架』</p><p>中间的梁架又称为『正身梁架』，两侧为『山面梁架』</p><p>每一个『正立面』都对应一副正身木构架。</p><p>按构造形式，又分两种方式，一种是『抬梁式』，一种是『穿斗式』，抬梁式的特点是：柱上加梁，梁上立短柱，不断循环增加梁架高度（穿斗式未讲）</p><p>宋代的抬梁式殿分为『殿堂型』和『厅堂型』，殿堂型的内外柱等高，结构水平层次明显，常用于等级较高的大殿，其他多用结构更加自由的厅堂型</p><p>以下为殿堂型的正身梁架</p><p>从上到下</p><p>屋面最内侧为『望板』（望板可不加，可直接在椽子上铺瓦）</p><p>直接支撑椽子的是『槫』（tuán），不同年代又叫作桁（hēng）或叫檩（lǐn）</p><p>为防止檐椽倾覆，『悬挑』（屋檐露出的部分）部分要比其他部分小</p><p>屋架主要由『槫』和『栿』组成，屋脊下的槫称为『脊团』，悬挑出檐的槫为『撩风槫』（又可叫作檐槫）撩风槫可由圆形构造换成截面直角梯形的『橑檐枋』</p><p>脊团和撩风槫之间的槫为『平槫』，最高的平槫叫『上平槫』，同理最低的平槫叫『下平槫』，其余的统称为『中平槫』。槫一般在前后屋对称分布。</p><p>两槫的水平投影距离为『槫架长』，一个屋架的总架数可用于描述殿宇的进深大小（详看上期总结）。</p><p>槫一般架在栿的一端，栿按长度命名，上承四架长的为『四槫栿』，六架长的为『六槫栿』。而二架长又分情况，脊梁下的为『平梁』，其余的为『乳栿』。一架长的栿为『劄牵』。</p><p>栿按室内是否可见，又分为『明栿』（可见）和『草栿』（不可见）</p><p>每层梁栿之间有一些支撑结构，雕刻为山状的支撑物为『驼峰』，倘若形状方正。则可以称作『垫木』，倘若短柱状且不落地，则称『蜀柱』。</p><p>栿外侧设倾斜支撑槫的部件称作『托脚』，脊槫下的一对托脚称为『叉手』，（宋代的托脚只顶到槫，而唐代却要顶到梁栿的两头）叉手常常要与蜀柱并用。</p><p>平行于栿的部件为正身方向部件，垂直于栿的部件为顺身方向部件，一栋建筑常在顺身方向将一组正身梁架连续排列，构成梁架的主要部分。</p><h2 id="举折法"><a href="#举折法" class="headerlink" title="举折法"></a>举折法</h2><p>屋面弧度的计算方法需要用到宋代官方的『举折法』。</p><p>举折法有两步，第一步『举屋』，第二步『折屋』。</p><p>首先是举屋，举屋是计算屋顶的总高度 $H$，此处的 $H$ 是以最下端的栿的最高距离到脊槫的中轴距离。</p><p>若为等级较高的殿阁楼台，则测量前后撩风槫的中轴的水平距离，记作 $B$，则 $H = \frac{B}{3}$ （唐代则是 $\frac{B}{4}$）假如所得值不为整数，则取相近值即可。</p><p>若不是等级较高的殿阁楼台，有斗拱的测量前后凉风图案中轴的水平距离，无斗拱的测量前后檐柱中轴的水平距离 $H = \frac{B}{4} + x$ （此处的 $x$ 为特定值）</p><p>筒瓦厅堂 $x = 0.02B$</p><p>筒瓦廊屋及板瓦厅堂 $x = 0.0125B$</p><p>板瓦廊屋 $x = 0.0075B$ </p><p>（同样，具体只需取附近值即可）</p><p>然后就是折屋，首先确定脊槫、撩风槫，连接。（连接的位置为脊槫的最上方和撩风槫的最上方，连线可用 $aseprite$ 进行辅助）</p><p>找该线与上平槫处沿垂线的交点，下降总举高的 $\frac{1}{10}$ ，即确定了此处上平槫的中轴位置。同理再次连接撩风槫与上一次确定的槫，下降 $\frac{1}{20}$ ….（之后以此类推）</p><p>确定两个槫中轴的距离，将其记作 $n$，若最长的栿为六槫栿，则 $\frac{B}{2} = 3n + (3+1)$</p><p>若最长的椽为八椽栿，则 $\frac{B}{2} = 4n + (4+1)$</p><p>若最长的椽为 $x$椽栿，则 $\frac{B}{2} = xn + (x + 1)$</p><p>2021/10/25 新学</p>]]></content>
    
    
    <categories>
      
      <category>建筑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>建筑</tag>
      
      <tag>举折法</tag>
      
      <tag>正身木构架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷书表记录</title>
    <link href="/2021/10/23/%E5%88%B7%E4%B9%A6%E8%A1%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/10/23/%E5%88%B7%E4%B9%A6%E8%A1%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p><img src="https://www.giaott.com/images/2022/07/06/2U7ft.jpg"></p><p>从基础开始，重新开始刷书，此表为刷书记录表</p><p>使用网站：<a href="https://www.acwing.com/activity/content/punch_the_clock/6/"><strong>AcWing</strong></a></p><p>使用书籍：<strong>算法竞赛进阶指南</strong></p><p>2021/10/25 <a href="https://lovehshan.top/2021/10/25/a%E7%9A%84b%E6%AC%A1%E6%96%B9/">a^b</a></p><p>2021/10/26 <a href="https://lovehshan.top/2021/10/26/64%E4%BD%8D%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95/">64位数整数乘法</a></p><p>2021/10/26 <a href="https://lovehshan.top/2021/10/26/%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84/">最短Hamilton路径</a></p><p>2021/10/27 <a href="https://lovehshan.top/2021/10/27/%E8%B5%B7%E5%BA%8A%E5%9B%B0%E9%9A%BE%E7%BB%BC%E5%90%88%E7%97%87/">起床困难综合症</a></p><p>2021/10/27 <a href="https://lovehshan.top/2021/10/27/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8C%87%E6%95%B0%E5%9E%8B%E6%9E%9A%E4%B8%BE/">递归实现指数型枚举</a></p><p>2021/10/28 <a href="https://lovehshan.top/2021/10/28/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE/">递归实现组合型枚举</a></p><p>2021/10/28 <a href="https://lovehshan.top/2021/10/28/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E5%9E%8B%E6%9E%9A%E4%B8%BE/">递归实现组合型枚举</a></p><p>2021/10/28 <a href="https://lovehshan.top/2021/10/28/%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/">费解的开关</a></p><p>2021/10/29 <a href="https://lovehshan.top/2021/10/29/%E5%A5%87%E6%80%AA%E7%9A%84%E6%B1%89%E8%AF%BA%E5%A1%94/">奇怪的汉诺塔</a></p><p>2021/10/29 <a href="https://lovehshan.top/2021/10/29/%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C/">约数之和</a></p><p>2022/1/8 <a href="https://lovehshan.top/2022/01/08/%E5%88%86%E5%BD%A2%E4%B9%8B%E5%9F%8E/">分形之城</a></p><p>2022/1/8 <a href="https://lovehshan.top/2022/01/08/%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9/">激光炸弹</a></p><p>2022/1/10 <a href="https://lovehshan.top/2022/01/10/%E5%A2%9E%E5%87%8F%E5%BA%8F%E5%88%97/">增减序列</a></p><p>2022/1/11 <a href="https://lovehshan.top/2022/01/11/%E6%9C%80%E9%AB%98%E7%9A%84%E7%89%9B/">最高的牛</a></p><p>2022/1/11 <a href="https://lovehshan.top/2022/01/11/%E6%9C%80%E4%BD%B3%E7%89%9B%E5%9B%B4%E6%A0%8F/">最佳牛围栏</a></p><p>2022/1/15 <a href="https://lovehshan.top/2022/01/15/%E7%94%B5%E5%BD%B1/">电影</a></p><p>2022/1/16 <a href="https://lovehshan.top/2022/01/16/%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80/">货仓选址</a></p><p>2022/7/1 <a href="https://lovehshan.top/2022/06/30/%E4%B8%83%E5%A4%95%E7%A5%AD/">七夕祭</a></p><p>2022/7/2 <a href="https://lovehshan.top/2022/07/02/%E5%8A%A8%E6%80%81%E4%B8%AD%E4%BD%8D%E6%95%B0/">动态中位数</a></p><p>2022/7/2 <a href="https://lovehshan.top/2022/07/02/%E8%B6%85%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">超快速排序</a></p><p>2022/7/4 <a href="https://lovehshan.top/2022/07/04/%E5%A5%87%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/">奇数码问题</a></p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>ACM</tag>
      
      <tag>OI</tag>
      
      <tag>算法竞赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>必修一筑网层作业笔记反馈</title>
    <link href="/2021/10/23/%E5%BF%85%E4%BF%AE%E4%B8%80%E7%AD%91%E7%BD%91%E5%B1%82%E4%BD%9C%E4%B8%9A%E7%AC%94%E8%AE%B0%E5%8F%8D%E9%A6%88/"/>
    <url>/2021/10/23/%E5%BF%85%E4%BF%AE%E4%B8%80%E7%AD%91%E7%BD%91%E5%B1%82%E4%BD%9C%E4%B8%9A%E7%AC%94%E8%AE%B0%E5%8F%8D%E9%A6%88/</url>
    
    <content type="html"><![CDATA[<h1 id="必修一筑网层作业笔记反馈"><a href="#必修一筑网层作业笔记反馈" class="headerlink" title="必修一筑网层作业笔记反馈"></a>必修一筑网层作业笔记反馈</h1><blockquote><p>课件使用 @2020明城京联合太学 必修一·唐宋梁架基础 筑网层</p></blockquote><p>一座单层古建筑大致可以分为：『上分』『中分』『下分』</p><p>中分又分为：『柱网层』『铺作层』</p><p>由 落地柱 和 地基 组成的平面称作 『柱网』</p><p>柱子由 柱头、柱身、柱脚 组成</p><p>落地柱分为 『外柱（檐柱）』『内柱』</p><p>柱子一般由 『阑额』进行连接，若由两根平行的水平梁连接，上面的叫『阑额』，下面的叫『由额』，中间加的短柱叫做『蜀柱』，蜀柱不落地，阑额和由额都属于『额枋』，额枋是水平梁的一种。</p><p>柱一般落在网格点上，去除柱子的做法叫作『减柱造』，移动柱子的做法叫作『移柱造』，通常减柱和移柱不发生在檐柱上。</p><p>有阑额的柱子之间叫作『槽』，外柱为『外槽』，内柱为『内槽』</p><p>柱网层正面的广度叫作『通面阔』（正面间的数量），侧面的深度叫作『通进深』（侧面间的数量）</p><p>由四个槽围成的空间叫作『间』</p><p>同理，间的正面广度为『间广』（正面的长度），侧面的深度叫作『间深』（侧面的长度）</p><p>含有檐柱的间，若柱网层通面阔为<strong>奇数</strong>，则中间的间为『明间』或『当心间』，若为<strong>偶数</strong>则无明间，四个角的间为『梢间』，明间与梢间之间的间叫作『次间』，若无明间，则两个梢间之间的间叫作次间</p><p>唐代的明间与次间等宽，宋代的明间&gt;次间&gt;梢间</p><p>关于柱网，有一系列的预设，叫作『分槽制度』，其中含有</p><ul><li>满堂红（不减柱）</li><li>单槽（分成前、后两个大小不等的空间）</li><li>分心槽（分成前、后两个大小相等的空间）</li><li>双槽（分成前，中，后三个大小不等的空间，中间的空间大于前后）</li><li>分心斗底槽（在分心槽的基础上，纵向加入了双槽的元素，使其组成六块空间，中间两个空间相等且大于另外四个相等的空间）</li><li>金箱斗底槽（由内外两圈柱组成类似回的结构）</li></ul><p>2021/10/23 新学</p><p>2021/10/25 复习</p>]]></content>
    
    
    <categories>
      
      <category>建筑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>建筑</tag>
      
      <tag>柱网层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/10/21/hello-world/"/>
    <url>/2021/10/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>2021/10/21 新建博客</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10月番剧自追表</title>
    <link href="/2021/10/21/10%E6%9C%88%E7%95%AA%E5%89%A7%E8%87%AA%E8%BF%BD%E8%A1%A8/"/>
    <url>/2021/10/21/10%E6%9C%88%E7%95%AA%E5%89%A7%E8%87%AA%E8%BF%BD%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="番剧自追表"><a href="#番剧自追表" class="headerlink" title="番剧自追表"></a>番剧自追表</h1><p><strong>前排提示：只含自己感兴趣的番，不含所有的10月新番</strong></p><h2 id="续作："><a href="#续作：" class="headerlink" title="续作："></a>续作：</h2><h3 id="异世界食堂第二季"><a href="#异世界食堂第二季" class="headerlink" title="异世界食堂第二季"></a>异世界食堂第二季</h3><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi1.go2yd.com%2Fimage.php%3Furl%3D0Y1M37ho4e&refer=http%3A%2F%2Fi1.go2yd.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637380853&t=164b34eae4154c8910f83e66dddf2c78"></p><h3 id="鬼灭之刃第二季"><a href="#鬼灭之刃第二季" class="headerlink" title="鬼灭之刃第二季"></a>鬼灭之刃第二季</h3><p><img src="http://n.sinaimg.cn/sinakd20210714ac/54/w1080h1374/20210714/1312-8211b10908836a2259b260d11b3625c1.jpg"></p><h2 id="补看"><a href="#补看" class="headerlink" title="补看"></a>补看</h2><h3 id="异世界食堂第一季"><a href="#异世界食堂第一季" class="headerlink" title="异世界食堂第一季"></a>异世界食堂第一季</h3><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farchive%2Ffd28362702b154aaa9e6c4dfcbbae289014f62e4.jpg&refer=http%3A%2F%2Fi0.hdslb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637380125&t=ad9433fb6310b30ab2c31dfdbe6f470a"></p><h3 id="异世界四重奏"><a href="#异世界四重奏" class="headerlink" title="异世界四重奏"></a>异世界四重奏</h3><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F8112f60f3827afa729b8aaa6ae02446c36133b56.jpg&refer=http%3A%2F%2Fi0.hdslb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637380159&t=014daa274f06357839942340942ddccf"></p><h2 id="新作"><a href="#新作" class="headerlink" title="新作"></a>新作</h2><h3 id="看得见的女孩"><a href="#看得见的女孩" class="headerlink" title="看得见的女孩"></a>看得见的女孩</h3><p class="note note-info">恐怖、搞笑</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg0.178.com%2Facg1%2F202109%2F426467401532%2F426467496693.jpg&refer=http%3A%2F%2Fimg0.178.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637380185&t=f5cbe5a8ba5313a4513df4a669bf4e8c"></p><h3 id="古见同学有交流障碍症"><a href="#古见同学有交流障碍症" class="headerlink" title="古见同学有交流障碍症"></a>古见同学有交流障碍症</h3><p class="note note-info">青春 搞笑</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F14081634201%2F1000&refer=http%3A%2F%2Finews.gtimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637380257&t=f8f2806de3fd5d87ad63f6e26bc001e9"></p><h3 id="键等"><a href="#键等" class="headerlink" title="键等"></a>键等</h3><p class="note note-info">key社大杂烩</p><p><img src="https://img0.baidu.com/it/u=3454684694,294388592&fm=253&fmt=auto&app=120&f=JPEG?w=899&h=500"></p><h3 id="蓝色时期"><a href="#蓝色时期" class="headerlink" title="蓝色时期"></a>蓝色时期</h3><p class="note note-info">青春 励志 画画</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F14080750605%2F1000&refer=http%3A%2F%2Finews.gtimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637380460&t=25a5275a8b0c73228d1b88a6f1846db1"></p><h3 id="世界最强暗杀者转生成异世界贵族"><a href="#世界最强暗杀者转生成异世界贵族" class="headerlink" title="世界最强暗杀者转生成异世界贵族"></a>世界最强暗杀者转生成异世界贵族</h3><p class="note note-info">异世界转生 龙傲天 后宫闪光</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.3dmgame.com%2Fuploads%2Fimages%2Fnews%2F20210523%2F1621735730_266570.jpg&refer=http%3A%2F%2Fimg.3dmgame.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637380601&t=08b60326ac6b61efd6c302e62c2667d7"></p><h3 id="我被逐出队伍后过上慢生活"><a href="#我被逐出队伍后过上慢生活" class="headerlink" title="我被逐出队伍后过上慢生活"></a>我被逐出队伍后过上慢生活</h3><p class="note note-info">异世界 后宫</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg01.sogoucdn.com%2Fapp%2Fa%2F200863%2Fimg_url_709327_163299073942496&refer=http%3A%2F%2Fimg01.sogoucdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637380891&t=5e0e01f2b8a1826c531616fea58ffb49"></p><h3 id="世界尽头的圣骑士"><a href="#世界尽头的圣骑士" class="headerlink" title="世界尽头的圣骑士"></a>世界尽头的圣骑士</h3><p class="note note-info">热血 慢节奏 温馨</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F89f0233a4b4f8668542313564b788a675c9ecdc9.jpg&refer=http%3A%2F%2Fi0.hdslb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637380768&t=caaa3299e47d852177a57e7da96d4347"></p><h3 id="吸血鬼马上死"><a href="#吸血鬼马上死" class="headerlink" title="吸血鬼马上死"></a>吸血鬼马上死</h3><p class="note note-info">搞笑 吸血鬼</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp3.itc.cn%2Fq_70%2Fimages03%2F20210328%2F3a27af0ea5ad41639bb7517254872c14.png&refer=http%3A%2F%2Fp3.itc.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637380931&t=532dc61120ccc8b152ecfaad2d60ae12"></p><h3 id="Visual-Prison"><a href="#Visual-Prison" class="headerlink" title="Visual Prison"></a>Visual Prison</h3><p class="note note-info">男团 音乐 吸血鬼</p><p><img src="https://img1.baidu.com/it/u=2962708266,588238830&fm=253&fmt=auto&app=120&f=JPG?w=640&h=355"></p><h3 id="Deji-Meets-Girl"><a href="#Deji-Meets-Girl" class="headerlink" title="Deji Meets Girl"></a>Deji Meets Girl</h3><p class="note note-info">青春恋爱 画风超棒</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ftva1.sinaimg.cn%2Fcrop.0.0.9999.9999.780%2Fa183a0f1ly1gsy3smrcrtj20u016itio.jpg&refer=http%3A%2F%2Ftva1.sinaimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637381147&t=615f581e6f8d35bb00d79ac852342e8e"></p><h3 id="Deep-Insanity（狂热深渊）"><a href="#Deep-Insanity（狂热深渊）" class="headerlink" title="Deep Insanity（狂热深渊）"></a>Deep Insanity（狂热深渊）</h3><p class="note note-info">原创番抽奖</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.3dmgame.com%2Fuploads%2Fimages%2Fnews%2F20210625%2F1624611652_666205.jpg&refer=http%3A%2F%2Fimg.3dmgame.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637381167&t=5a7c84ce8a0e066a77c632eaecfb50ca"></p><h3 id="Selection-Project"><a href="#Selection-Project" class="headerlink" title="Selection Project"></a>Selection Project</h3><p class="note note-info">偶像番</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fnimg.ws.126.net%2F%3Furl%3Dhttp%253A%252F%252Fdingyue.ws.126.net%252F2021%252F1012%252F76f43197j00r0uu4u001nc000hs00bdg.jpg%26thumbnail%3D650x2147483647%26quality%3D80%26type%3Djpg&refer=http%3A%2F%2Fnimg.ws.126.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637381192&t=d5150e6e616e5e636b1d6d45d33b6d92"></p><h3 id="SAKUGAN"><a href="#SAKUGAN" class="headerlink" title="SAKUGAN"></a>SAKUGAN</h3><p class="note note-info">地下城迷宫探险 父女 两集吃刀</p<p><img src="https://img0.baidu.com/it/u=2925334248,2934658684&fm=253&fmt=auto&app=120&f=JPEG?w=640&h=360"></p><h3 id="国王排名"><a href="#国王排名" class="headerlink" title="国王排名"></a>国王排名</h3><p class="note note-info">霸权社10周年作品 staff全部大佬（上一个还是封神的一拳） 自认十月霸权</p><p><img src="https://img1.baidu.com/it/u=972711372,2513010224&fm=253&fmt=auto&app=120&f=PNG?w=469&h=431"></p><p>里番推荐</p><p>是否已满18岁？ <a class="btn" href="https://lovehshan.top/2021/10/21/%E5%8D%81%E6%9C%88%E9%87%8C%E7%95%AA/" title="里番推荐">是，我已满18岁</a></p>]]></content>
    
    
    <categories>
      
      <category>番剧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>番剧</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
